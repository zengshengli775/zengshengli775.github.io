<!-- build time:Fri Feb 18 2022 14:26:09 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><meta name="referrer" content="no-referrer"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakura" href="https://zengshengli775.gitee.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakura" href="https://zengshengli775.gitee.io/atom.xml"><link rel="alternate" type="application/json" title="Sakura" href="https://zengshengli775.gitee.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://zengshengli775.gitee.io/2021/11/11/%E6%9C%9F%E6%9C%AB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"><title>| Sakura = Sakura = 我以为18岁之后是19岁，19岁之后是18岁，20岁永远都不会到来 。</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline"></h1><div class="meta"><span class="item" title="创建时间：2021-11-11 14:34:53"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-11-11T14:34:53+08:00">2021-11-11</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>27k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>25 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Sakura</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="http://www.dmoe.cc/random.php?811006"></li><li class="item" data-background-image="http://www.dmoe.cc/random.php?134275"></li><li class="item" data-background-image="http://www.dmoe.cc/random.php?762431"></li><li class="item" data-background-image="http://www.dmoe.cc/random.php?243995"></li><li class="item" data-background-image="http://www.dmoe.cc/random.php?462502"></li><li class="item" data-background-image="http://www.dmoe.cc/random.php?980159"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://zengshengli775.gitee.io/2021/11/11/%E6%9C%9F%E6%9C%AB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="lzs"><meta itemprop="description" content="我以为18岁之后是19岁，19岁之后是18岁，20岁永远都不会到来 。, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakura"></span><div class="body md" itemprop="articleBody"><hr><p>title: 操作系统概念 - 学习笔记<br>date: 2021.12.11<br>categories:</p><ul><li>期末<br>tags:</li><li>操作系统<br>description: 目录第一章、导论 1.1 操作系统 1.1.1 用户视角 1.1.2 系统视角 1.1.3 定义操作系统 1.2 计算机系统组织 1.2.1 计算机系统操作 1.2.2 存储结构 1.2.3 I/O 结构 1.3 计算机系统体系结构 1.4 . 操作系统结构 1.5 操作系统操作 1.5.1 操作系统的双重模式操作 1.5.2 定时器第二章 操作系统结构 2.1 操...</li></ul><h1 id="操作系统概念-学习笔记"><a class="anchor" href="#操作系统概念-学习笔记">#</a> <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcyL2FydGljbGUvZGV0YWlscy84ODgyODM2MQ==">操作系统概念 学习笔记</span></h1><h1 id="第一章-导论"><a class="anchor" href="#第一章-导论">#</a> 第一章、导论</h1><h2 id="11-操作系统"><a class="anchor" href="#11-操作系统">#</a> 1.1 操作系统</h2><p><strong>1. 计算机系统四个组成部分</strong></p><p>计算机硬件、操作系统、系统程序和用户程序、用户。</p><p><img data-src="https://cdn.jsdelivr.net/gh/1910853272/image/img/202111111544225.png" alt=""><br>硬件为系统提供了基本的计算资源。应用程序规定了用户按何种方式使用这些资源，操作系统不过提供了一个方便其它程序做有用工作的环境。</p><h3 id="111-用户视角"><a class="anchor" href="#111-用户视角">#</a> 1.1.1 用户视角</h3><h3 id="112-系统视角"><a class="anchor" href="#112-系统视角">#</a> 1.1.2 系统视角</h3><blockquote><p>操作系统看作资源分配器。</p></blockquote><ul><li>操作系统管理这些资源</li><li>面对冲突的资源请求，操作系统必须决定如何为各个程序和用户分配资源，以便计算机系统能有效而公平的运行。</li></ul><p>操作系统是 <strong>控制程序</strong>，管理用户程序的执行防止计算机资源的错误使用或使用不当。</p><h3 id="113-定义操作系统"><a class="anchor" href="#113-定义操作系统">#</a> <strong>1.1.3 定义操作系统</strong></h3><p>操作系统是一组控制和管理计算机硬件和软件资源、合理地对各类作业进行调度，以及方便用户的程序集合。<br><strong>3. 操作系统的目标</strong></p><p>执行用户程序，更容易地解决用户问题。</p><p>使计算机系统使用方便。</p><p>有效地使用计算机硬件。</p><h1 id="12-计算机系统组织"><a class="anchor" href="#12-计算机系统组织">#</a> 1.2 计算机系统组织</h1><h2 id="121-计算机系统操作"><a class="anchor" href="#121-计算机系统操作">#</a> 1.2.1 计算机系统操作</h2><p>现代通用计算机系统由一个或多个 CPU 和若干 <strong>设备控制器</strong>通过共同的总线相连而成。</p><p>打开电源或重启 —— 运行 <strong>初始化程序</strong>（引导程序）—— 定位操作系统并将其装入内存 —— 执行第一个进程</p><p><strong>引导程序</strong>：通常位于 ROM 或者 EEPROM，称为计算机硬件中的固件。用来初始化系统的所有部分（CPU 寄存器，设备控制器和内存）。<br><strong>中断</strong>：硬件可随时通过系统总线向 CPU 发出信号，出发中断。软件通过系统调用（或者其他特别操作）触发中断。<br>发生中断 —— 调用一个通用子程序检查中断信息 —— 使用中断处理指针表（ <strong>中断向量</strong>）—— 间接调用中断处理子程序</p><p>现在的操作系统都是以 <strong>中断</strong>为驱动的。</p><h3 id="122-存储结构"><a class="anchor" href="#122-存储结构">#</a> 1.2.2 存储结构</h3><p>内存是处理器可以直接访问的唯一的大容量存储区域</p><p><strong>辅存</strong>：一般是磁盘。（因为内存太小，而且是易失性存储设备。）</p><p>各种存储系统的差别主要是速度、价格、大小和易失性。</p><p><strong>易失性</strong>：断电时，会丢失内容</p><p>价格逐渐降低，大小逐渐增大，速度逐渐减慢，主存以上易失，</p><p><img data-src="https://cdn.jsdelivr.net/gh/1910853272/image/img/202111111544532.png" alt=""></p><h3 id="123-io结构"><a class="anchor" href="#123-io结构">#</a> 1.2.3 I/O 结构</h3><p>通用计算机系统由一个 CPU 和多个设备控制器组成。通过共同的总线连接起来，每个设备控制器负责特定类型的设备，可有多个设备与其相连。</p><p>SCSI (small computer system interface) 控制器可以有 7 个或更多的设备相连。</p><p>设备控制器</p><ul><li>维护一定量的本地缓冲存储和一组特定用途的寄存器</li><li>复制在其控制的外部设备与本地缓冲存储之间进行数据传递</li><li>通常每个设备控制器都有一个设备驱动程序</li></ul><p>I/O 中断驱动 (适合少量的数据)</p><ul><li>设备驱动程序在设备控制器中装载适当的寄存器</li><li>设备控制器检查寄存器状态决定操作</li><li>控制器开始向本地缓冲区传输数据</li><li>设备控制器通过中断通知设备驱动程序已完成操作</li><li>设备驱动程序返回对系统的控制。</li></ul><p>DMA (direct memory access) 直接内存访问</p><p>设备直接写入内存而不需要 CPU 的干预，每一块只产生一个中断。</p><p>交换使得各个部件并发对话而不是在总线上争夺事件，更加地高效</p><h2 id="13-计算机系统体系结构"><a class="anchor" href="#13-计算机系统体系结构">#</a> 1.3 计算机系统体系结构</h2><p>单处理器系统、多处理器系统、集群系统</p><p><strong>单处理器系统</strong></p><ul><li>只有一个通用 CPU</li><li>还包含其他特定目的微处理器， 用来克服主 CPU 超载问题</li></ul><p><strong>多处理器系统（并行系统、紧耦合系统）</strong></p><p>定义：多处理器系统有多个紧密通信的 CPU，它们共享计算机总线，有时还有时钟、内存和外设等。</p><p><strong>优点：</strong></p><p>增加吞吐量、规模经济、增加可靠性。</p><p><strong>分类：</strong></p><p>非对称多处理：每个处理器都有各自特定的任务。一个主处理器控制系统，其他处理器或者向主处理器要任务或做预先定义的任务。</p><p>对称多处理：每个处理器都要完成操作系统中的所有任务。所有处理器对等，处理器之间没有主 - 从关系。<br><strong>集群系统</strong></p><p>由两个或多个独立的系统耦合起来的，通过局域网连接或更快的内部连接 (InfiniBand)</p><p>用途： 提供高可用性 (high availability) 服务</p><p>分类：对称与非对称</p><p>非对称集群 (asymmetric clustering) 中， 一台机器处于热备份状态 (hot standby mode)，另一台运行程序。</p><p>对称集群 (symmetric clustering)，两个或多个主机都运行程序并互相监视。</p><p>还有并行集群和 WAN 集群。</p><p>并行集群中通常需要分布式锁管理器 (distributed lock manager， DLM)</p><h2 id="14-操作系统结构"><a class="anchor" href="#14-操作系统结构">#</a> 1.4 操作系统结构</h2><p>分时操作系统、多道程序设计</p><p>进程 (process): 装到内存并执行的程序</p><p>作业调度 (job scheduling)： 在储存在磁盘作业池 (job pool) 中与主存中的作业做出决策和安排</p><p>CPU 调度 (CPU scheduling)： 多个任务同时执行</p><p>在分时操作系统中，为了保证合理的相应时间，就需要通过交换来得到。通常使用虚拟内存 (virtual memory) 实现。</p><h2 id="15-操作系统操作"><a class="anchor" href="#15-操作系统操作">#</a> 1.5 操作系统操作</h2><h3 id="151-操作系统的双重模式操作"><a class="anchor" href="#151-操作系统的双重模式操作">#</a> 1.5.1 操作系统的双重模式操作</h3><p>为了区分操作系统代码和用户定义代码的执行，至少需要两种独立的操作模式 <strong>：用户模式、监督程序模式</strong>（管理模式、系统模式、特权模式）。</p><p>将能引起损害的机器指令作为 <strong>特权指令</strong>。用户模式下想要执行特权指令，硬件不会执行，会认为是非法指令，并以陷阱的形式通知操作系统。<br>系统引导时，硬件开始处于 ** 内核模式。** 接着，装入操作系统，开始进入用户模式。出现陷阱或中断，会进入内核模式。</p><p>转换到用户模式就是一个特权指令。</p><p><img data-src="https://cdn.jsdelivr.net/gh/1910853272/image/img/202111111611598.png" alt=""></p><h3 id="152-定时器"><a class="anchor" href="#152-定时器">#</a> 1.5.2 定时器</h3><p>防止用户进入死循环或不调用系统服务。定时器在给定时间后中断计算机。操作系统将控制权交给用户之前，设置 ** 定时器。** 修改定时器的操作就是特权指令。</p><h1 id="第二章-操作系统结构"><a class="anchor" href="#第二章-操作系统结构">#</a> 第二章 操作系统结构</h1><h2 id="21-操作系统服务"><a class="anchor" href="#21-操作系统服务">#</a> 2.1 操作系统服务</h2><p>用户界面（一种是命令行界面；另一种是批界面，最为常用的是图形用户面）、程序执行、I/O 操作、文件系统操作、通信、错误检测、资源分配、统计、保护和安全。</p><h2 id="22-操作系统的用户界面"><a class="anchor" href="#22-操作系统的用户界面">#</a> <strong>2.2 操作系统的用户界面</strong></h2><p>命令解释程序（CLI）被成为外壳（shell）、图形用户界面（GUI）<br><strong>命令解释程序主要作用</strong></p><p>获取并执行用户指定的下一条指令。</p><h2 id="23-系统调用system-call"><a class="anchor" href="#23-系统调用system-call">#</a> 2.3 系统调用（System Call）</h2><p><strong>系统调用</strong>提供了操作系统提供的有效服务界面。</p><p>操作系统内核提供一系列预定功能，通过一组称为系统调用的接口呈现给编程人员，系统调用把应用程序的请求传给内核，系统调用相应的内核函数完成所需的处理，将处理结果返回给应用程序。<br><strong>向操作系统传递参数的三种方法</strong></p><ul><li>通过寄存器来传递参数。</li><li>若参数数量比寄存器多，参数通常存在内存的块和表中，并将块的地址通过寄存器来传递。</li><li>参数也可以通过程序放在或压入堆栈中，并通过操作系统弹出。</li></ul><p><img data-src="https://img-blog.csdnimg.cn/2019032813034779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="24-系统调用类型"><a class="anchor" href="#24-系统调用类型">#</a> 2.4 系统调用类型</h2><p>进程控制、文件管理、设备管理、信息维护和通信</p><h2 id="25-系统程序分类"><a class="anchor" href="#25-系统程序分类">#</a> 2.5 系统程序分类</h2><p>文件管理、状态信息、文件修改、程序语言支持、程序装入和执行、通信。</p><h2 id="26-操作系统设计和实现"><a class="anchor" href="#26-操作系统设计和实现">#</a> 2.6 操作系统设计和实现</h2><h4 id="设计目标"><a class="anchor" href="#设计目标">#</a> 设计目标</h4><p>定义系统的目标和规格</p><p>系统类型：批处理、 分时、 单用户、 多用户、 分布式、 实时、 通用目标</p><p>两个基本类： 用户目标和系统目标</p><h4 id="机制mechanism和策略policy"><a class="anchor" href="#机制mechanism和策略policy">#</a> 机制（mechanism）和策略（policy）</h4><p>区分机制和策略对于灵活性很重要</p><ul><li>机制决定如何做</li><li>策略决定做什么，策略可能随时间或位置而有所改变。</li></ul><h4 id="实现"><a class="anchor" href="#实现">#</a> 实现</h4><p>现代操作系统一般都是用高级语言编写， 如 C 或 C++</p><p>代码编写更快， 更为紧凑，容易理解和调试。</p><p>缺点仅仅为降低了速度和增加了存储要求</p><h2 id="27-操作系统结构"><a class="anchor" href="#27-操作系统结构">#</a> 2.7 操作系统结构</h2><p>简单结构、分层方法、微内核、模块、虚拟机.</p><h3 id="271-简单结构"><a class="anchor" href="#271-简单结构">#</a> 2.7.1 简单结构</h3><p>MS-DOS、原始的 UNIX 操作系统</p><h3 id="272-分层方法"><a class="anchor" href="#272-分层方法">#</a> <strong>2.7.2 分层方法</strong></h3><p><strong>定义</strong>：操作系统分成若干层（级）。最底层（层 0）为硬件，最高层（层 N）为用户接口。每层只考虑较低层的功能和服务。</p><p><strong>优点：</strong></p><ul><li>每层都是利用较低层所提供的功能实现的，并为叫高层隐藏了一定的数据结构、操作和硬件的存在</li></ul><p><strong>缺点：</strong></p><ul><li>分层法的主要困难涉及对层的详细定义</li><li>与其它方法相比效率较差</li></ul><h3 id="273-微内核"><a class="anchor" href="#273-微内核">#</a> 2.7.3 微内核</h3><p>微内核方法将所有非基本部分从内核中移走，并将它们实现为系统或用户程序，这样得到了更小的内核。</p><p>微内核的主要功能是使客户程序和运行在用户空间的各种服务之间进行通信。</p><p><strong>优点：</strong></p><ul><li>便于扩充操作系统</li><li>很容易从一种硬件平台设计移植到另一种硬件平台设计</li><li>更安全、可靠</li></ul><p><strong>缺点：</strong></p><p>由于系统功能总开销的增加而导致系统性能的下降。</p><h3 id="274-模块"><a class="anchor" href="#274-模块">#</a> 2.7.4 模块</h3><p>大多数现代操作系统实现内核模块：</p><ul><li>使用面向对象 (object-oriented) 方法</li><li>每个核心组件分离</li><li>模块通过接口 (interfaces) 互相调用</li><li>每个模块都作为内核中的可加载模块</li></ul><p>总之，类似于层，但更灵活。</p><h2 id="28-虚拟机"><a class="anchor" href="#28-虚拟机">#</a> 2.8 虚拟机</h2><p>虚拟机（VirtualMachine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。</p><h1 id="第三章-进程"><a class="anchor" href="#第三章-进程">#</a> 第三章 进程</h1><h2 id="31-进程概念"><a class="anchor" href="#31-进程概念">#</a> 3.1 进程概念</h2><h3 id="311-进程"><a class="anchor" href="#311-进程">#</a> 3.1.1 进程</h3><p>进程包含了程序代码和当前活动（其中当前活动通过程序计数器和处理器寄存器的内容表示）两个部分，进程是执行中的程序。具体有：</p><ul><li>文本段（代码段）</li><li>数据段（全局变量）</li><li>栈（stack）（包含临时数据、函数参数、返回地址、局部变量）</li><li>堆（heap）（进程运行期间动态分配的内存）</li><li>程序计数器</li></ul><p><strong>注意</strong>： 程序是被动实体，进程是活动实体（其中当前活动通过程序计数器和处理器寄存器的内容表示）</p><p>两个进程可以与同一程序联系，虽然文本段相同。但是数据段、堆栈段不同</p><h3 id="312-进程状态"><a class="anchor" href="#312-进程状态">#</a> 3.1.2 进程状态</h3><p>进程有 5 种状态，包括：</p><ul><li>New（新的）</li><li>Running（运行）</li><li>Waiting（等待）</li><li>Ready（就绪）</li><li>Terminated（终止）</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/1910853272/image/img/202111112124875.png" alt=""></p><p>注意：一次只有一个进程能在一个处理器上运行（Running 态），但在处理器上运行的时候，其他进程可以进行 IO 操作（想一下 DMC 模式）</p><h3 id="313-进程控制块pcb"><a class="anchor" href="#313-进程控制块pcb">#</a> 3.1.3 进程控制块（PCB）</h3><p>Process control block， PCB， 也称任务控制块（信息的仓库）</p><p>包括：</p><ul><li>进程状态</li><li>程序计数器</li><li>CPU 寄存器</li><li>CPU 调度信息<ul><li>优先级</li><li>调度队列的指针</li><li>其他调度参数</li></ul></li><li>内存管理信息<ul><li>基址</li><li>界限寄存器的值</li><li>页表</li><li>段表</li></ul></li><li>记账信息<ul><li>CPU 时间</li><li>实际使用时间</li><li>时间界限</li><li>记账数据</li><li>作业或进程数量</li></ul></li><li>I/O 状态信息<ul><li>I/O 设备列表</li><li>打开的文件列表</li></ul></li></ul><p>CPU 通过保存 PCB 来进行进程间的切换</p><h2 id="32-进程调度"><a class="anchor" href="#32-进程调度">#</a> 3.2、进程调度</h2><p>目的：使 CPU 的利用率最大化，需要优化进程调度的方法</p><p>进程调度程序选择一个进程到 CPU 上执行（一个 CPU 一个时间段只能执行一个程序，其余程序需要等待 CPU 空闲重新调度）</p><h3 id="321-调度队列"><a class="anchor" href="#321-调度队列">#</a> 3.2.1 调度队列</h3><p><strong>作业（Job）队列</strong>：包含了系统中所有的进程<br><strong>就绪（Ready）队列</strong>：包含了系统中，驻留在 <strong>内存</strong>中就绪的，准备运行的进程<br>该队列通常用链表实现，头结点指向第一个和最后一个 PCB 块的指针，每个 PCB 块包括指向下一个 PCB 的指针域<br><strong>设备（Device）队列</strong>：包含了等待特定 IO 设备的进程列表<br>进程可能会有 IO 请求，请求时可能 IO 设备在处理其他请求，所以该进程需要等待。</p><p>讨论进程调度的常用方法是队列图<br><img data-src="https://img-blog.csdnimg.cn/20190326195440363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70" alt=""><br>其中包括了就绪队列和设备队列（可能有多个设备队列）</p><p><img data-src="https://img-blog.csdnimg.cn/20190326195552195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="322-调度程序"><a class="anchor" href="#322-调度程序">#</a> 3.2.2 调度程序</h3><p>通常对于批处理系统，进程更多的是被提交、放到大容量存储设备的缓冲池中，保存在那里以便之后执行，在这之后，需要通过调度程序来选择缓冲池中的进程装入内存，并执行</p><p>进程选择由相应的调度程序执行，有两类调度程序：</p><p><strong>长期调度程序（long-term schedule） / 作业调度程序（job schedule）</strong>：负责从缓冲池中选择进程，装入内存以便执行<br><strong>短期调度程序（short-term schedule） / CPU 调度程序（CPU schedule）</strong>：从执行的进程中选择进程，并为之分配 CPU</p><p>有的系统，如分时系统，加入了中期调度程序（medium-term schedule），其核心思想是能将进程从内存（或 CPU 竞争中）移出，从而降低多道程序设计的难度，之后，进程可被重新调入内存，并从中断处执行。通过中期调度程序，进程可换出，并在之后换入，这种方案称为交换<br><img data-src="https://img-blog.csdnimg.cn/20190326195710199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>各类进程调度的特点：</strong></p><p>长期调度程序执行的不频繁（进程创建期间可能间隔数分钟）<br>短期调度程序执行的非常频繁（毫秒级），因此需要程序执行的速度非常快<br>长期调度程序控制多道程序（multiprogramming）设计的程度，在稳定情况下，创建进程的速度应该等于进程离开系统的平均速度</p><p><strong>进程的类型</strong></p><p>IO 为主（就是操作主要是 IO 传输）</p><p>CPU 为主（就是操作主要是各种运算）</p><h3 id="323-上下文切换"><a class="anchor" href="#323-上下文切换">#</a> 3.2.3 上下文切换</h3><p>中断使 CPU 从当前任务改变为运行内核子程序。当发生一次中断的时候，系统需要保存当前 <strong>程序的上下文</strong>，在恢复程序时需要恢复程序的上下文。</p><p>将 CPU 切换到另一个进程需要保存当前程序的状态并恢复另一个程序的状态，这个任务叫做 <strong>上下文切换</strong></p><p><strong>进程的上下文也就是进程的 PCB</strong>，上文提到过它的组成</p><p><strong>上下文切换的类型：</strong></p><p><strong>状态保存</strong>（state save）：保存当前 CPU 的状态（不论是内核模式还是用户模式）<br><strong>状态恢复</strong>（state restore）：重新开始之前保存的状态</p><p>上下文切换是额外开销，切换时系统不能做其他任何有用的工作。其消耗的时间为几毫秒，具体的时间消耗和硬件支持密切相关</p><p>有的操作系统提供了多组寄存器集合，上下文切换只需要简单改变当前寄存器组的指针。</p><h2 id="33-进程操作"><a class="anchor" href="#33-进程操作">#</a> 3.3 进程操作</h2><p>绝大多数系统内的进程能够并发执行，并动态的创建和删除，因此操作系统应该提供一种机制来 <strong>创建 / 终止</strong>进程（即进程操作）</p><h3 id="331-进程创建"><a class="anchor" href="#331-进程创建">#</a> 3.3.1 进程创建</h3><p>进程树：进程在执行过程中，能够继续创建进程（系统调用），创建进程的进程为 <strong>父进程</strong>，被创建的进程是 <strong>子进程</strong>，以此类推，形成了进程树</p><p>一般系统都有一个 <strong>根进程</strong>，负责创建其他所有的进程，这样一个系统的进程树只有一棵</p><p>进程是需要一定的资源的（CPU 时间，内存，文件，IO 设备），在一个进程创建子进程的时候， <strong>在父进程和子进程之间需要分配 / 共享资源，有以下几种情况：</strong></p><ul><li>从操作系统哪里获取资源</li><li>从父进程中获取资源（限制子进程只能从父进程中获取资源能防止创建过多的进程导致系统超载）</li></ul><p><strong>在进程创建时，该进程会得到：</strong></p><ul><li>各种物理和逻辑资源</li><li>父进程传递来的初始化数据或输入</li><li>通常子进程会返回给父进程自身的标识符（系统中唯一标识进程身份的 id）</li></ul><p><strong>在进程执行时，有以下几种情况：</strong></p><ul><li>父进程和子进程并发执行</li><li>父进程等待，直到子进程执行完毕</li></ul><p><strong>创建的新进程的地址空间有两种可能</strong>：</p><ul><li>子进程是父进程的复制品（有相同的程序和数据）</li><li>子进程内装入另一个新程序</li></ul><p><strong>关于 fork () 和 exec ()：</strong></p><ul><li>fork 命令创建一个新的进程</li><li>exec 命令在 fork 命令后执行，用于将新的程序装入进程的内存空间</li></ul><h5 id="unix-中"><a class="anchor" href="#unix-中">#</a> UNIX 中</h5><p>通过 <code>fork()</code> 创建新进程。新进程通过复制原来进程的地址空间而成。</p><p>对于新进程，系统调用 <code>fork()</code> 返回值为 0，对于父进程，返回值为子进程的进程标识符。</p><p>在 <code>fork()</code> 之后，一个进程使用 <code>exec()</code> ，可以用新程序来取代进程的内存空间。</p><p>这样两个进程就可以互相通信并可以通过各自的方式执行。</p><p>如果子进程运行时没有什么可以做，那么就可以采用 <code>wait()</code> 把自己移出就绪队列来<strong>等待子进程</strong>的终止。</p><p>Copy</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Fork Failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span> <span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child Complete"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>PS: <code>Copy on write</code> : 需要写的时候才发生内存复制。</p><h5 id="windows-中"><a class="anchor" href="#windows-中">#</a> Windows 中</h5><p>使用 <code>Win32 API</code> 中的 <code>CreateProcess()</code> 函数， 执行时，函数将一个特殊程序装入子进程的地址空间。需要至少 10 个参数。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">CreateProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span>` 需要两个参数`STARTUPINFO` 和 `PROCESS_INFORMATION</pre></td></tr></table></figure><p><code>STARTUPINFO</code> 指明新进程的许多特性，如窗口大小、标准输入及输出文件句柄</p><p><code>PROCESS_INFORMATION</code> 包括一个句柄以及新生成进程和线程的标识</p><p>调用前，需要使用 <code>ZeroMenory()</code> 为这两个结构清空内存</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>Win32 API`相对于`Linux` 的`<span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>`是`<span class="token function">WaitForSingleObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h3 id="332-进程终止"><a class="anchor" href="#332-进程终止">#</a> 3.3.2 进程终止</h3><p><strong>进程终止的时间：</strong></p><ul><li>执行完最后语句，并使用系统调用 exit () 请求操作系统删除自身。</li><li>一个进程通过适当的系统调用终止另一个进程（通常这个进程需要是被终止进程的父进程，并且这需要知道被终止进程的标识符）</li></ul><p><strong>父进程终止子进程的原因一般有：</strong></p><ul><li><ul><li>子进程使用的资源超过了父进程分配的资源</li></ul></li><li><ul><li>分配给子进程的任务不再需要</li></ul></li><li><ul><li>父进程退出，在这种情况下，操作系统不允许子进程继续。有些系统如果一个进程终止，那么它所有的子进程都终止。这叫做 ** 级联终止。** 通常有操作系统进行</li></ul></li></ul><p><strong>进程终止后：</strong></p><p>进程会返回状 <strong>态值（通常为整数）到父进程 &lt;br&gt; 所有进程资源会被操作系统释放</strong></p><p>如果父进程终止，那么其所有子进程会以 init 进程作为父进程。因此，子进程仍然有一个父进程来收集状态和执行统计</p><h2 id="34-进程间通信"><a class="anchor" href="#34-进程间通信">#</a> 3.4 进程间通信</h2><p>并发执行的进程有两类，一类是 <strong>独立进程</strong>，不能影响其他进程并且不被其他进程影响。<br>另一类是 <strong>协作进程</strong>，能影响其他进程或被其他进程影响</p><p><strong>允许进程协作的优点：</strong></p><ul><li>信息共享</li><li>提高运算速度</li><li>模块化</li><li>方便</li></ul><p>因此协作进程需要一种进程间通信机制（IPC）来允许进程相互交换数据与信息。有 <strong>共享内存和信息传递</strong>两种类型</p><h3 id="341共享内存系统"><a class="anchor" href="#341共享内存系统">#</a> <img data-src="https://img-blog.csdnimg.cn/20190326201024565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70" alt="">3.4.1 共享内存系统</h3><p>生产者进程产生信息以供消费者进程消费，共享内存时解决<strong>生产者 - 消费者</strong>问题方法中的一种。</p><p>有两种缓冲方式：</p><ul><li>无限缓冲（unbounded-buffer）：消费者可能不得不等待新的项， 生产者总是可以产生新项。</li><li>有限缓冲（bounded-buffer）：缓冲大小固定，如果缓冲为空，消费者等待，如果缓冲为满，生产者等待。</li></ul><p>生产者进程：</p><p>Copy</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>item nextProduced</pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>in <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> BUFFER_SIZE<span class="token punctuation">)</span> <span class="token operator">==</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当缓冲满了的时候必须等待</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	buffer<span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token operator">=</span> nextProduced<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	in <span class="token operator">=</span> <span class="token punctuation">(</span>in <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> BUFFER_SIZE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>消费者进程:</p><p>Copy</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>item nextConsumed</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">while</span> <span class="token punctuation">(</span>in <span class="token operator">==</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当缓冲为空的时候必须等待</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	nextConsumed <span class="token operator">=</span> buffer<span class="token punctuation">[</span>out<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	out <span class="token operator">=</span> <span class="token punctuation">(</span>out <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> BUFFER_SIZE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="342消息传递系统"><a class="anchor" href="#342消息传递系统">#</a> 3.4.2 消息传递系统</h3><p>常用于分布式环境中，如 Web</p><p>消息传递提供一种机制允许进程不必通过共享地址空间来实现通讯与同步</p><p>通信需要有通信线路（communication link）</p><p>通讯线路的实现：</p><ul><li>物理：共享内存、硬件总线</li><li>逻辑：逻辑属性 properties</li></ul><p>逻辑实现线路和发送接收操作的方法：</p><ul><li>直接或间接通信</li><li>同步或异步通信</li><li>自动或显式缓冲</li></ul><h5 id="命名"><a class="anchor" href="#命名">#</a> 命名</h5><p>对于直接通信：</p><p>对称寻址：</p><ul><li><code>send(P, message)</code> : 发送信息到进程 P</li><li><code>receive(Q, message)</code> : 接受来自进程 Q 的信息</li></ul><p>属性：</p><ul><li>每对需要通信的进程之间自动建立线路，进程仅需知道相互通信的标识符</li><li>一个线路只与两个进程相关</li><li>每对进程之间只有一个线路</li></ul><p>非对称寻址：</p><ul><li><code>send(P, message)</code> : 发送信息到进程 P</li><li><code>receive(id, message)</code> : 接受来自任何进程的信息，id 设置成与其通信的进程名称</li></ul><p>这两种寻址方式的缺点在于限制了进程定义的模式化，改变进程名字需要检查其他所有进程的定义。</p><p>对于间接通信：</p><p>通过邮箱和端口来发送或接受信息。</p><p>一个进程可能通过许多不同的邮箱与其他进程通信，但两个进程仅在其共享至少一个邮箱时可以相互通信。</p><ul><li><code>send(A, message)</code> ： 发送一个消息到邮箱 A</li><li><code>receive(A, message)</code> : 接受来自邮箱 A 的消息</li></ul><p>对于这种方案，通信线路有如下属性：</p><ul><li>只有在两个进程共享一个邮箱，才能建立通信线路</li><li>一个线路可以与两个或更多的进程相关联</li><li>两个通信进程之间可有多个不同的线路，每个线路对于一个邮箱</li><li>连接可能是单向 <code>unidirectional</code> 或者双向 <code>bi-directional</code></li></ul><p>操作系统需提供的机制：</p><ul><li>创建新邮箱</li><li>通过邮箱发送和接受消息</li><li>删除邮箱</li></ul><p>邮箱的拥有权和接受权可以通过系统调用传递给其他进程。</p><h5 id="同步"><a class="anchor" href="#同步">#</a> 同步</h5><p>消息传递可以是阻塞或非阻塞（同步或异步）</p><ul><li>阻塞发送 send： 发送进程阻塞， 直到消息被接受进程或邮箱所接受</li><li>非阻塞发送 send： 发送进程发送消息并再继续操作</li><li>阻塞接收 receive： 接收者阻塞， 直到有消息可用</li><li>非阻塞接收 receive： 接收者收到一个有效信息或空信息</li></ul><p>当 <code>send()</code> 和 <code>receive()</code> 都阻塞， 发送者和接收者之间就有一个 <code>集合点（rendezvous）</code></p><h5 id="缓冲"><a class="anchor" href="#缓冲">#</a> 缓冲</h5><ul><li>无缓冲<ul><li>零容量：阻塞</li></ul></li><li>自动缓冲<ul><li>有限容量： 线路满后阻塞</li><li>无限容量： 不阻塞</li></ul></li></ul><h3 id="客户机-服务器系统通信"><a class="anchor" href="#客户机-服务器系统通信">#</a> 客户机 - 服务器系统通信</h3><p>除了共享内存和消息传递，还有三种通信方法： Socket、远程过程调用（RPC）和 Java 的远程方法调用（RMI）</p><h4 id="socket"><a class="anchor" href="#socket">#</a> Socket</h4><p>Socket（套接字）可定义为通信的端点。一对通过网络通信的进程需要使用一对 Socket（即每个进程各有一个）。</p><p>Socket 由 IP 地址和一个端口号连接组成</p><p>服务器通过 <strong>监听制定端口</strong> 来等待进来的客户请求， 一旦受到请求， 就接受来自客户 Socket 的连接， 从而完成连接。</p><p>Java 提供了三种不同类型的 Socket</p><ul><li>面向连接（TCP）Socket： Socket 类</li><li>无连接（UDP）Socket： DatagramSocket 类</li><li>多点传送 Socket： DatagramSocket 的子类（允许数据发送到多个接收者）</li></ul><p>使用 Socket 通信，虽然常用和高效， 但是属于较为低级的分布式进程通信。原因之一在于 Socket 只允许在通信进程之间交换 ** 无结构的字节流 **</p><h4 id="远程过程调用"><a class="anchor" href="#远程过程调用">#</a> 远程过程调用</h4><p>Remote Procedure Calls, RPC</p><p>RPC 抽象层远程调用机制，用于通过网络连接系统</p><p>存根 Stubs： 用于服务器上的实际程序的客户端代理</p><p>客户端使用存根定位服务器，并提供参数</p><p>服务器接收信息，解析后运行指定的程序</p><h2><a class="anchor" href="#">#</a></h2><h1 id="第四章-线程"><a class="anchor" href="#第四章-线程">#</a> 第四章 线程</h1><h2 id="41-概述"><a class="anchor" href="#41-概述">#</a> 4.1 概述</h2><p>线程是 CPU 使用的基本单元，由 <strong>线程 ID</strong>， <strong>程序计数器</strong>， <strong>寄存器集</strong>合和 <strong>栈</strong>组成。它与属于同一进程的其他线程 <strong>共享代码段，数据段和其他操作系统资源。</strong></p><p><img data-src="https://cdn.jsdelivr.net/gh/1910853272/image/img/202111112325970.png" alt=""></p><h3 id="411-多线程编程的优点"><a class="anchor" href="#411-多线程编程的优点">#</a> 4.1.1 多线程编程的优点</h3><ol><li>响应度高：一个多线程的程序即使部分阻塞，其他部分仍能运行，从而增加了对用户的响应程度。</li><li>资源共享</li><li>经济：创建和切换线程比创建进程更节省资源和时间</li><li>多处理器体系结构的利用：多线程能充分利用多处理器体系</li></ol><h2 id="42-多线程模型"><a class="anchor" href="#42-多线程模型">#</a> 4.2 多线程模型</h2><p>提供多线程支持有两种方式： <strong>用户线程</strong>和 <strong>内核线程</strong></p><ul><li>用户线程受内核支持，无须内核管理</li><li>内核线程由操作系统支持和管理</li></ul><p>在用户线程和内核线程之间存在一定的关系，即 <strong>多线程模型</strong>，以下讨论三种常用的关系：多对一，一对一，多对多</p><h3 id="421-多对一模型"><a class="anchor" href="#421-多对一模型">#</a> 4.2.1 多对一模型</h3><p>多个用户线程映射到一个内核线程</p><ul><li>优点：线程管理由线程库在用户空间完成，效率比较高</li><li>缺点：如果一个线程阻塞，整个进程就会阻塞；且多个线程无法并行运行在多处理器上</li></ul><p><img data-src="https://img-blog.csdn.net/20180410093948774?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NhaWxpc3Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h3 id="422-一对一模型"><a class="anchor" href="#422-一对一模型">#</a> 4.2.2 一对一模型</h3><p>每个用户线程映射到一个内核线程上</p><ul><li>优点：比多对一模型更好的并发功能；一个线程阻塞时，其他线程能够继续调用；多个线程能够并发运行在多处理器</li><li>缺点：创建内核线程的开销会影响应用程序的功能</li></ul><h1 id="-2"><a class="anchor" href="#-2">#</a> <img data-src="https://img-blog.csdnimg.cn/20190326205452929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70" alt=""></h1><h3 id="423-多对多模型"><a class="anchor" href="#423-多对多模型">#</a> 4.2.3 多对多模型</h3><ul><li>多对一模型可以创建任意多的用户线程，但是只能没有增加并发性</li><li>一对一模型增强了并发性，但开发者要小心不能在应用程序中创建太多的进程</li></ul><p>多对多模型没有上述的所有缺点，它多路复用了许多用户线程到同样数量或更小数量的内核线程上</p><h1 id="-3"><a class="anchor" href="#-3">#</a> <img data-src="https://img-blog.csdnimg.cn/20190326205512427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70" alt=""></h1><h1 id="-4"><a class="anchor" href="#-4">#</a> <img data-src="https://img-blog.csdnimg.cn/20190326205609531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70" alt=""></h1><h2 id="43-线程库"><a class="anchor" href="#43-线程库">#</a> 4.3 线程库</h2><blockquote><p>在用户空间中提供一个没有内核支持的库<br>执行一个由操作系统直接支持的内核级的库</p></blockquote><h2 id="44-多线程问题"><a class="anchor" href="#44-多线程问题">#</a> 4.4 多线程问题</h2><h3 id="441-系统调用fork和exec"><a class="anchor" href="#441-系统调用fork和exec">#</a> 4.4.1 系统调用 fork () 和 exec ()</h3><p>在多线程程序中，系统调用 fork () 和 exec () 的语义有所改变。</p><p>如果程序中一个进程调用 fork ()，那么新进程会复制所有线程，还是新进程只有单个线程？有的 UNIX 系统有两种形式的 fork ()， <strong>一种复制所有线程，另一种只复制调用了系统调用 fork () 的线程。</strong></p><p>Exec () 工作方式：如果一个线程调用系统调用 exec ()，那么 exec () 参数所指定的程序会替换整个进程，包括所有线程。</p><p>如果调用 fork () 之后立即调用 exec ()，那么没有必要复制所有线程，因为 exec () 参数所指定的程序会替换整个进程。在这种情况下，只复制调用线程比较适当。不过，如果在 fork () 之后另一进程并不调用 exec (), 那么另一进程就应复制所有进程。</p><h3 id="442-取消"><a class="anchor" href="#442-取消">#</a> 4.4.2 取消</h3><p>线程取消（thread cancellation）是在线程完成之前来终止线程的任务。</p><p>要取消的线程通常称为 <strong>目标线程</strong>。目标线程的取消可在如下两种情况下发生：</p><p>一是 <strong>异步取消</strong>（asynchronous cancellation）：一个线程立即终止目标线程。</p><p>二是 <strong>延迟取消</strong>（deferred cancellation）：目标线程不断地检查它是否应终止，这允许目标线程有机会以有序方式来终止自己。</p><p>如果资源已经分配給要取消的线程，或者要取消的线程正在更新与其他线程所共享的数据，那么取消会有困难，对于异步取消尤为麻烦。操作系统回收取消线程的系统资源，但是通常不回收所有资源。因此，异步取消线程并不会使所需的资源空闲。相反采用延迟取消时，允许一个线程检查它是否是在安系统资源空闲全的点被取消，pthread 称这些点为 <strong>取消点</strong>（cancellation point）。</p><h3 id="443-信号处理"><a class="anchor" href="#443-信号处理">#</a> 4.4.3 信号处理</h3><p>信号处理：信号在 Unix 中用来通知进程某个特定时间已发生了，信号可以同步或异步接收。所有有信号具有同样的模式：</p><p>（1）信号有特定事件的发生所产生</p><p>（2）产生的信号要发送到进程</p><p>（3）一旦发送，信号必须交易处理。</p><p>同步信号的例子包括访问非法内存或被 0 除。在这种情况下，如果运行程序执行这些动作，那么就产生信号，同步信号发送到执行操作而产生信号的同一进程（同步的原因）。</p><p>当一个信号由运行进程之外的事件产生，那么进程就异步接收这一信号。这种信号的例子包括使用特殊键（Ctrl + C）或者定时器到期。通常，异步信号被发送到另一个进程。</p><p><strong>每个信号可能由两种可能的处理程序中的一种来处理：</strong></p><p>（1）默认信号处理程序</p><p>（2）用户定义的信号处理程序</p><p>每个信号都有一个默认信号处理程序，当处理信号是在内核中运行的，这种默认动作可以用用户定义的信号处理程序来改写。信号可以按照不同的方式处理。有的信号可以简单的忽略（如改变窗口大小），有的需要终止程序来处理（非法内存访问）</p><p>单线程程序的信号处理比较直接，信号总是发送给 <strong>进程</strong>。</p><p><strong>当多线程时，信号会</strong></p><p>（1）发送信号到信号所应用的线程</p><p>（2）发送信号到进程内的每个线程</p><p>（3）发送信号到进程内的某些固定线程</p><p>（4）规定一个特定线程以接收进程的所有信号。</p><p>发送信号的方法依赖于信号的类型。</p><h3 id="444-线程池"><a class="anchor" href="#444-线程池">#</a> 4.4.4 线程池</h3><p>多线程服务器有一些潜在问题：第一个是关于处理请求之前用以创建线程的时间，以及线程在完成工作之后就要被丢弃这一事实。第二个，如果允许所有并发请求都通过新线程来处理，那么将没法限制在系统中并发执行的线程的数量。无限制的线程会耗尽系统资源。解决这一问题是使用 <strong>线程池</strong>。</p><p>线程池的思想是在进程开始时创建一定数量的线程，并放入到池中以等待工作。当服务器收到请求时，他会唤醒池中的一个线程，并将要处理的请求传递给他，一旦线程完成了服务，它会返回到池中在等待工作。如果池中没有可用的线程，那么服务器会一直等待直到有空线程为止。</p><p><strong>线程池的优点：</strong></p><p>（1）通常用现有线程处理请求要比等待创建新的线程要快</p><p>（2）线程池限制了在任何时候可用线程的数量。</p><p>线程池中的线程数量由系统 CPU 的数量、物理内存的大小和并发客户请求的期望值等因素决定。比较高级的线程池能动态的调整线程的数量，以适应具体情况。</p><h3 id="445-线程特定数据"><a class="anchor" href="#445-线程特定数据">#</a> 4.4.5 线程特定数据</h3><p>同属一个进程的线程共享进程数据。</p><p>在某些情况下每个线程可能需要一定数据的自己的 <strong>副本</strong>，这种数据称为 <strong>线程特定数据</strong>。可以让每个线程与其唯一的标识符相关联。</p><h1 id="第五章-cpu调度"><a class="anchor" href="#第五章-cpu调度">#</a> 第五章 CPU 调度</h1><h2 id="51-基本概念"><a class="anchor" href="#51-基本概念">#</a> 5.1 基本概念</h2><p>多道程序操作系统的基础。通过在进程之间切换 CPU，操作系统可以提高计算机的吞吐率。<br>对于单处理器系统，每次只允许一个进程运行：任何其他进程必须等待，直到 CPU 空闲能被调度为止。</p><h3 id="511-cpu-io-区间周期"><a class="anchor" href="#511-cpu-io-区间周期">#</a> 5.1.1 CPU-I/O 区间周期</h3><p>CPU 的成功调度依赖于进程的如下属性：</p><p>进程执行由 <strong>CPU 执行周期</strong>和 <strong>I/O 等待周期</strong>组成。进程在这两个状态之间切换 (CPU burst—I/O bust)。</p><p>进程执行从 CPU 区间（CPU burst）开始，在这之后是 I/O 区间（I/O burst）。接着另外一个 CPU 区间，然后是另外一个 I/O 区间，如此进行下去，最终，最后的 CPU 区间通过系统请求中止执行。</p><p><img data-src="https://cdn.jsdelivr.net/gh/1910853272/image/img/202111122103853.png" alt=""></p><p>经过大量 CPU 区间的长度的测试。发现具有大量短 CPU 区间和少量长 CPU 区间。I/O 约束程序通常具有很多短 CPU 区间。CPU 约束程序可能有少量的长 CPU 区间。这种分布有助于选择合适的 CPU 调度算法。</p><h3 id="512-cpu程序调度"><a class="anchor" href="#512-cpu程序调度">#</a> 5.1.2 CPU 程序调度</h3><p>每当 CPU 空闲时，操作系统就必须从就绪队列中选择一个进程来执行。进程选择由短期调度程序（short-term scheduler）或 CPU 调度程序执行。调度程序从内存中选择一个能够执行的进程，并为之分配 CPU。</p><p>就绪队列不必是先进先出（FIFO）队列，也可为优先队列、树或简单的无序链表。不过队列中所有的进程都要排队以等待在 CPU 上运行。队列中的记录通常为进程控制块（PCB）。</p><h3 id="513-抢占调度"><a class="anchor" href="#513-抢占调度">#</a> 5.1.3 抢占调度</h3><p>CPU 调度决策可在如下 4 种情况环境下发生：</p><p>（1）当一个进程从运行切换到等待状态（如：I/O 请求，或者调用 wait 等待一个子进程的终止）</p><p>（2）当一个进程从运行状态切换到就绪状态（如：出现中断）</p><p>（3）当一个进程从等待状态切换到就绪状态（如：I/O 完成）</p><p>（4）当一个进程终止时</p><p>对于第 1 和 4 两种情况，没有选择而只有调度。一个新进程（如果就绪队列中已有一个进程存在）必须被选择执行。对于第２和第３两种情况，可以进行选择。</p><p>当调度只能发生在第 1 和 4 两种情况下时，称调度是非抢占的（nonpreemptive）或协作的（cooperative）；否则，称调度方案为 <strong>抢占的</strong>（preemptive）。采用非抢占调度，一旦 CPU 分配给一个进程，那么该进程会一直使用 CPU 直到进程终止或切换到等待状态。</p><p>抢占调度对访问共享数据是有代价（如加锁）的，有可能产生错误，需要新的机制（如，同步）来协调对共享数据的访问。</p><p>抢占对于操作系统内核的设计也有影响。在处理系统调用时，内核可能忙于进程活动。这些活动可能涉及要改变重要内核数据 (如 I/O 队列)。</p><p>因为根据定义中断能随时发生，而且不能总是被内核所忽视，所以受中断影响的代码段必须加以保护以避免同时访问。操作系统需要在任何时候都能够接收中断，否则输入会丢失或输出会被改写。为了这些代码段不被多个进程同时访问，在进入时就要禁止中断，而在退出时要重新允许中断。</p><h3 id="514-分派程序"><a class="anchor" href="#514-分派程序">#</a> 5.1.4 分派程序</h3><p>** 分派程序（**dispatch）是一个模块，用来将 CPU 的控制交给由短期调度程序选择的进程。<br><strong>其功能包括</strong>：</p><p>切换上下文<br>切换到用户模式<br>跳转到用户程序的合适位置，以重新启动程序。</p><p>分派程序停止一个进程而启动另一个所花的时间成为 <strong>分派延迟</strong>。</p><h2 id="52-调度准则"><a class="anchor" href="#52-调度准则">#</a> 5.2 调度准则</h2><p><strong>为了比较 CPU 调度算法所提出的准则：</strong></p><p><strong>CPU 使用率</strong>：需要使 CPU 尽可能忙<br><strong>吞吐量</strong>：指一个时间单元内所完成进程的数量<br>** 周转时间 😗* 从进程提交到进程完成的时间段称为周转时间，周转时间是所有时间段之和，包括等待进入内存、在就绪队列中等待、在 CPU 上执行和 I/O 执行<br><strong>等待时间</strong>：在就绪队列中等待所花费时间之和<br><strong>响应时间</strong>：从提交请求到产生第一响应的时间</p><p>需要使 CPU 使用率和吞吐量最大化，而使周转时间、等待时间和响应时间最小化。绝大多数情况下需要优化平均值，有时需要优化最大值或最小值，而不是平均值。</p><h2 id="53-调度算法"><a class="anchor" href="#53-调度算法">#</a> 5.3 调度算法</h2><h3 id="531-先到先服务调度first-comefirst-served-scheduling"><a class="anchor" href="#531-先到先服务调度first-comefirst-served-scheduling">#</a> 5.3.1 先到先服务调度 (First-Come，First-Served scheduling)</h3><p>最简单的 CPU 调度算法是先到先服务算法（First-Come，First-Served scheduling）：先请求 CPU 的进程先分配到 CPU。FCFS 策略可以用 FIFO 队列来容易实现。当一个进程进入就绪队列，其 PCB 链接到队列的尾部。当 CPU 空闲时，CPU 分配给位于队列头的进程，接着运行进程从队列中删除。</p><p>FCFS 策略的代码编写简单且容易理解，不过采用 FCFS 策略的平均等待时间通常比较长。当进程 CPU 区间时间变化很大，平均等待时间会变化很大。</p><p>比如以下例子<br>进程 区间时间<br>P1 24<br>P2 3<br>P3 3</p><p>如果按照 P1 P2 P3</p><p>顺序到达，Gantt 图如下:</p><p><img data-src="https://img-blog.csdnimg.cn/20190326211224562.png" alt=""></p><p>平均等待时间：0+24+273=17</p><p>如果按 P2 P3 P1</p><p>顺序到达，</p><p>平均等待时间：0+3+63=3</p><p>另外考虑在动态情况下的性能，假设有一个 CPU 约束进程和许多 I/O 约束进程，CPU 约束进程会移回到就绪队列并被分配到 CPU。再次所有 I/O 进程会在就绪队列中等待 CPU 进程的完成。由于所有其他进程都等待一个大进程释放 CPU，这称之为 <strong>护航效果</strong>（convoy effect）。与让较短进程最先执行相比，这样会导致 CPU 和设备使用率变的很低。</p><p>FCFS 调度算法是 <strong>非抢占</strong>的。对于分时系统（每个用户需要定时的等待一定的 CPU 时间）是特别麻烦。允许一个进程保持 CPU 时间过长是个严重错误。</p><h3 id="532-最短作业优先调度shortest-job-first-schedulingsjf"><a class="anchor" href="#532-最短作业优先调度shortest-job-first-schedulingsjf">#</a> 5.3.2 最短作业优先调度 (shortest-job-first scheduling,SJF)</h3><p>将每个进程与下一个 CPU 区间段相关联。当 CPU 为空闲时，它会赋给具有最短 CPU 区间的进程。如果两个进程具有同样长度，那么可以使用 FCFS 调度来处理。注意，一个更为适当地表示是最短下一个 CPU 区间的算法，这是因为调度检查进程的下一个 CPU 区间的长度，而不是其总长度。</p><p>比如以下例子<br>进程 区间时间<br>P1 6<br>P2 8<br>P3 7<br>P4 3</p><p>SJF = 0+3+9+164=7</p><p>FCFS = 0+6+14+214=10.25</p><p>SJF 算法的平均等待时间最小。SJF 算法的真正困难是如何知道 <strong>下一个 CPU 区间的长度</strong>。对于批处理系统的长期（作业）调度，可以将用户提交作业时间所制定的进程时间极限作为长度。SJF 调度经常用于 <strong>长期调度</strong>。</p><p>它不能在短期 CPU 调度层次上加以实现。我们可以预测下一个 CPU 区间。认为下一个 CPU 区间的长度与以前的相似。因此通过计算下一个 CPU 区间长度的近似值，能选择具有最短预测 CPU 区间的进程来运行。 <strong>下一个 CPU 区间通常可预测为以前 CPU 去剪的测量长度的指数平均</strong>（exponential average）。</p><p>SJF 算法可能是 <strong>抢占的或非抢占的</strong>。抢占 SJF 算法可抢占当前运行的进程，而非抢占的 SJF 算法会允许当前的进程先完成其 CPU 区间。抢占 SJF 调度有时称为 ** 最短剩余时间优先调度（**shortest-remaining-time-first scheduling）。</p><p>比如以下例子<br>进程 到达时间 区间时间<br>P1 0 ８<br>P2 1 ４<br>P3 2 ９<br>P4 3 ５</p><p>根据 Gantt 图：</p><p><img data-src="https://img-blog.csdnimg.cn/20190326211409922.png" alt=""></p><p>平均等待时间：</p><p>0+0+(5−3)+(10−1)+(17−2)4=264=6.5</p><p>非抢占 SJF:</p><p>0+(8−1)+(12−3)+(17−2)4=7.75</p><h3 id="533-优先级调度priority-scheduling-algorithm"><a class="anchor" href="#533-优先级调度priority-scheduling-algorithm">#</a> 5.3.3 优先级调度 (priority scheduling algorithm)</h3><p>SJF 算法可作为通用的优先级调度算法的一个特例。每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到 CPU。具有相同优先级的进程按 FCFS 顺序调度。SJF，其优先级（p）为下一个 CPU 区间的倒数。CPU 区间越大，则优先级越小，反之亦然。</p><p>优先级通常是固定区间的数字，如０～７，但是数字大小与优先级的高低没有定论。</p><p>对于下例，假设数字越小优先级越高<br>进程 区间时间 优先级<br>P1 10 ３<br>P2 1 １<br>P3 2 ４<br>P4 1 ５<br>P5 5 ２</p><p>平均等待时间为：</p><p>0+1+6+16+185=8.2</p><p>优先级可通过内部或外部方式来定义。内部定义优先级使用一些测量数据以计算进程优先级。外部优先级是通过操作系统之外的准则来定义，如进程重要性等。</p><p><strong>优先级调度可以是抢占的或非抢占的。</strong></p><p>优先级调度算法的一个重要问题是 <strong>无限阻塞（indefinite blocking）或饥饿</strong>（starvation）。可以运行但缺乏 CPU 的进程可认为是阻塞的，它在等待 CPU。优先级调度算法会使某个有低优先级无穷等待 CPU。</p><p>低优先级进程务求等待问题的解决之一是 <strong>老化</strong>（aging）。老化是一种技术，以逐渐增加在系统中等待很长时间的进程的优先级。</p><h3 id="534-轮转法调度round-robinrr"><a class="anchor" href="#534-轮转法调度round-robinrr">#</a> 5.3.4 轮转法调度 (round-robin,RR)</h3><p>专门为分时系统设计。它类似于 FCFS 调度，但是 <strong>增加了抢占以切换进程</strong>。定义一个较小的时间单元，称为 <strong>时间片</strong>（time quantum，or time slice）。将就绪队列作为 <strong>循环队列</strong>。CPU 调度程序循环就绪队列，为每个进程分配不超过一个时间片段的 CPU。</p><p>新进程增加到就绪队列的尾部。CPU 调度程序从就绪队列中选择第一个进程，设置定时器在一个时间片之后中断，再分派该进程。接下来将可能发生两种情况。进程可能只需要小于时间片的 CPU 区间。对于这种情况，进程本身会自动释放 CPU。调度程序接着处理就绪队列的下一个进程。否则，如果当前运行进程的 CPU 区间比时间片要长，定时器会中断产生操作系统中断，然后进行上下文切换，将进程加入到就绪队列的尾部，接着 CPU 调度程序会选择就绪队列中的下一个进程。</p><p>RR 策略的平均等待时间通常较长</p><p>比如以下例子，使用４ms 时间片<br>进程 区间时间<br>P1 24<br>P2 3<br>P3 3</p><p>画出 Gantt 图：</p><p><img data-src="https://img-blog.csdnimg.cn/20190326211615960.png" alt=""></p><p>平均等待时间：</p><p>0+4+7+(10−4)3=5.66</p><p>如果就绪，那么每个进程会得到 1n<br>的 CPU 时间，其长度不超过 q 时间单元。每个进程必须等待 CPU 时间不会超过 (n−1)×q</p><p>个时间单元，直到它的下一个时间片为止。</p><p>RR 算法的性能很大程度上依赖于时间片的大小。在极端情况下，如果时间片非常大，那么 RR 算法与 FCFS 算法一样。如果时间片很小，那么 RR 算法称为处理器共享，n 个进程对于用户都有它自己的处理器，速度为真正处理器速度的 1/n。小的时间片会增加上下文切换的次数，因此，希望时间片比上下文切换时间长，事实上，绝大多数现代操作系统，上下文切换的时间仅占时间片的一小部分。周转时间也依赖于时间片的大小。</p><h3 id="535-多级队列调度multilevel-queue-scheduling"><a class="anchor" href="#535-多级队列调度multilevel-queue-scheduling">#</a> 5.3.5 多级队列调度 (Multilevel Queue Scheduling)</h3><p>前台（交互）进程和后台（批处理）进程。这两种不同各类型的进程具有不同响应时间要求，也有不同调度需要。与后台进程相比，前台进程要有更高（或外部定义）的优先级。</p><p>多级队列调度算法将就绪队列 <strong>分成多个独立队列</strong>。根据进程的属性，如内存大小等，一个进程被永久地分配到一个队列 (低调度开销但是不够灵活)，每个队列有自己的调度算法。前台队列可能采用 RR 算法调度，而后台调度可能采用 FCFS 算法调度。</p><p>另外，队 <strong>列之间必须有调度</strong>，通常采用固定优先级抢占调度，例如前台队列可以比后台队列具有绝对优先值。另一种可能在队列之间划分时间片例如，前台队列可以有 80% 的时间用于在进程之间进行 RR 调度，而后台队列可以有 20% 的 CPU 时间采用 FCFS 算法调度进程。</p><p>与多级队列调度相反，多级反馈队列调度允许进程在队列之间移动。主要思想是根据不同 CPU 区间的特点以区分进程。如果进程使用过多 CPU 时间，那么它可能被转移到较低优先级队列。这种方案将 I/O 约束和交互进程留在更高优先级队列。此外，在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。这种形式的老化组织饥饿的发生。</p><p><strong>通常，多级反馈队列调度程序可由下列参数来定义：</strong></p><ul><li>队列数量。</li><li>每个队列的调度算法。</li><li>用以确定何时升级到更高优先级队列的方法。</li><li>用以确定何时降级到更低优先级队列的方法。</li><li>用以确定进程在需要服务时应进入哪个队列的方法。</li></ul><h1 id="第六章-进程同步"><a class="anchor" href="#第六章-进程同步">#</a> 第六章 进程同步</h1><h2 id="61-背景"><a class="anchor" href="#61-背景">#</a> 6.1 背景</h2><p>互相协作的进程之间有 <strong>共享的数据</strong>，于是这里就有一个并发情况下，如何确保有序操作这些数据、维护一致性的问题，即 <strong>进程同步。</strong></p><p>从底层到高级应用，同步机制依次有临界区、信号量、管、原程子事务。</p><p>多个进程并发访问和操作同一数据且执行结果与访问发生的特定顺序有关，称之为 <strong>竞争条件</strong>（race condition）。</p><h3 id="62-临界区critical-section"><a class="anchor" href="#62-临界区critical-section">#</a> 6.2 临界区（critical section）</h3><p>每个进程有一个代码段（code segment）称为 <strong>临界区</strong>（critical section），在该区中进程可能改变共同变量、更新一个表或写一个文件等。这种系统的重要特征是当一个进程进入临界区，没有其他进程可被允许在临界区内执行，即没有两个进程可同时在临界区内执行。</p><p><strong>临界资源</strong>（Critical resource）每次只能被一个进程访问。而 <strong>临界区则是能够访问临界资源的代码片段</strong>。</p><p>临界区问题（critical-section problem）是设计一个以便进程协作的协议。每个进程必须请求允许进入其临界区。实现请求的代码段称为进入区（entry section），临界区之后可有退出区（exit section），其他代码段成为剩余区（remainder section）。</p><p>一个典型进程 Pi 的通用结构：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">do</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>进入区</pre></td></tr><tr><td data-num="3"></td><td><pre>    临界区</pre></td></tr><tr><td data-num="4"></td><td><pre>退出区</pre></td></tr><tr><td data-num="5"></td><td><pre>    剩余区</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span></pre></td></tr></table></figure><p><strong>临界区问题的解答必须满足三项要求：</strong></p><p>（1） <strong>互斥</strong>（mutual exclusion）：<br>如果进程 Pi 在其临界区内执行，那么其他进程都不能在其临界区内执行；</p><p>（2） <strong>前进</strong>（progress）：<br>如果没有进程在其临界区内执行且有进程需进入临界区，那么只有那么不在剩余区内执行的进程可参加选择，以确定谁能下一个进入临界区，且这种选择不能无限推迟；</p><p>（3） <strong>有限等待</strong>（bounded waiting）：<br>从一个进程做出进入临界区的请求，直到该请求允许为止，其他进程允许进入其临界区内的次数有上限。</p><p>一个操作系统，在某个时刻，可同时存在有多个处于内核模式的活动进程，因此实现操作系统的内核代码，会存在竞争条件。内核开发人员有必要确保其操作系统不会产生竞争条件。</p><p>有两种方法用于处理操作系统内的临界区问题：</p><p><strong>抢占内核（preemptive kernel）与非抢占内核</strong>（nonpreemptive kernel）：</p><p>抢占内核允许处于内核模式的进程被抢占。</p><p>非抢占内核不允许内核模式的进程被抢占。</p><p>非抢占内核的内核数据结构从根本上不会导致竞争条件，对于抢占内核需要认真设计以确保其内核数据结构不会导致竞争条件。</p><p>但抢占内核更受欢迎，因为抢占内核更适合实时编程，因为它能允许实时进程抢占处于内核模式运行的其他进程。再者，抢占内核的响应更快，因为处于内核模式的进程在释放 CPU 之前不会运行过久。</p><h2 id="63-peterson算法"><a class="anchor" href="#63-peterson算法">#</a> 6.3 Peterson 算法</h2><p>Peterson 算法是一种经典的基于 <strong>软件</strong>的临界区问题算法，可能现代计算机体系架构基本机器语言有些不同，不能确保正确运行。</p><p>Peterson 算法适用于两个进程在临界区与剩余区间交替执行，为了方便，当使用 Pi 时，Pj 来标示另一个进程，即 j=i−1。Peterson 算法需要在两个进程之间共享两个数据项：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> turn<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>boolean flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>变量 turn 表示哪个进程可以进入其临界区，即如果 turn==i，那么进程 Pi 允许在其临界区内执行。</p><p>数组 flag 表示哪个进程想要进入临界区，如果 flag [i] 为 true，即 Pi 想进入其临界区。</p><p>// 进程 Pi 的 Peterson 算法</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">do</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>   flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>TRUE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   turn<span class="token operator">=</span>j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>turn<span class="token operator">==</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>       <span class="token operator">&amp;</span>#x4E34<span class="token punctuation">;</span><span class="token operator">&amp;</span>#x754C<span class="token punctuation">;</span><span class="token operator">&amp;</span>#x533A<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>   flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>FALSE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>       <span class="token operator">&amp;</span>#x5269<span class="token punctuation">;</span><span class="token operator">&amp;</span>#x4F59<span class="token punctuation">;</span><span class="token operator">&amp;</span>#x533A<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span></pre></td></tr></table></figure><p>可以证明，满足三项要求。</p><p>Peterson 算法实际上是一种谦让的过程，即：<br>Pi：我已经准备好了，但是我让这次一次的 turn=j，看看 Pj 是否要运行，如果是的话，我就让 Pj 先运行。<br>Pj 也是这样的情况。</p><h2 id="64-硬件同步"><a class="anchor" href="#64-硬件同步">#</a> 6.4 硬件同步</h2><p>通过要求临界区用锁来防护，就可以避免竞争条件，即一个进程在进入临界区之前必须得到锁，而其退出临界区时释放锁。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    请求锁</pre></td></tr><tr><td data-num="3"></td><td><pre>        临界区</pre></td></tr><tr><td data-num="4"></td><td><pre>    释放锁</pre></td></tr><tr><td data-num="5"></td><td><pre>        剩余区</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>硬件特性能简化编程任务且提高系统效率。</p><p>对于单处理器环境，临界区问题可简单地加以解决：在修改共享变量时要禁止中断出现。这样其他指令不可能执行，所以共享变量也不会被意外修改。这种方法通常为抢占式内核所采用。</p><p>在多处理器环境下，这种解决方法是不可行的，低效且影响系统时钟。</p><p>特殊硬件指令以允许能 ** 原子地（** 不可中断的）检查和修改字的内容或交换两个字的内容。如 TestAndSet ()，当两个指令同时执行在不同的 CPU 上，那么它们会按任意顺序来顺序执行。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>boolean <span class="token function">TestAndSet</span><span class="token punctuation">(</span>boolean <span class="token operator">*</span>target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    boolean rv <span class="token operator">=</span> <span class="token operator">*</span>target<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token operator">*</span>target <span class="token operator">=</span> true<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> rv<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">TestAndSet</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// do something</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    lock <span class="token operator">=</span> false<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span>boolean <span class="token operator">*</span>a<span class="token punctuation">,</span> boolean <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    boolean temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    key <span class="token operator">=</span> true<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">// do something</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    lock <span class="token operator">=</span> false<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>使用 TestAndSet 的互斥实现，声明一个 Boolean 变量 lock，初始化为 false</p><pre><code>do&#123;
    while(TestAndSetLock(&amp;lock))
        ;//do nothing
        //critical section
    lock=FALSE;
        //remainder section
&#125;while(TRUE);
</code></pre><p><strong>Swap 指令的定义：</strong></p><pre><code>void Swap(boolean *a,boolean *b)
&#123;
  booleab temp=*a;
  *a=*b;
  *b=temp;
&#125;
</code></pre><p>使用 Swap 的互斥实现：key 为每个进程局部变量，lock 为全局变量，初始化为 false</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    key <span class="token operator">=</span> true<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// do something</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    lock <span class="token operator">=</span> false<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这些算法解决了互斥，但是并没有解决有限等待要求，因为所有的程序执行都是随机执行的问题。</p><p>下面介绍的使用 TestAndSet 的算法，该算法满足所有的临界区的三个要求。<br>公用的数据结构如下<br>boolean waiting [i] = TRUE;<br>boolean lock;<br>初始化均为 false。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">do</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  waiting<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>TRUE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  key<span class="token operator">=</span>TRUE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">while</span><span class="token punctuation">(</span>waiting<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    key<span class="token operator">=</span><span class="token function">TestAndSet</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  waiting<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>FALSE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">//critical section</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  j<span class="token operator">=</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>j<span class="token operator">!=</span>i<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token operator">!</span>waiting<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    j<span class="token operator">=</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    lock<span class="token operator">=</span>FALSE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">else</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    waiting<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>FALSE</pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">//remainder section</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>为了满足有限等待，当一个进程退出其临界区时，它会循环地扫描数组 waiting [i] 并根据这一顺序而指派第一个等待进程作为下一个进入临界区的进程。因此，任何等待进入临界区的进程只需要等待 n−1 次。<br>然而，对于硬件设计人员，在多处理器上实现原子指令 TestAndSet 并不简单。</p><h2 id="65-信号量semaphore"><a class="anchor" href="#65-信号量semaphore">#</a> 6.5 信号量 (semaphore)</h2><p>应用层面解决临界区问题： <strong>信号量</strong></p><p>信号量 S 是个整数变量，除了初始化外，它只能通过两个标准原子操作： <strong>wait () 和 signal () 来访问。即 P 和 V</strong>。</p><p>wait () 就是等待资源的过程，定义可表示为：</p><pre><code>wait(S)
&#123;
  while(S&lt;=0) ; no-op s--; &#125;&lt; code&gt;&lt;/=0)&gt;
</code></pre><p>signal () 就是释放资源的过程，定义可表示为：</p><pre><code>signal(S)
&#123;
  S++;
&#125;
</code></pre><p>在 wait () 和 signal () 操作中，对信号量整型值的修改必须不可分地执行。即当一个进程修改信号量值时，不能有其他进程同时修改同一信号量的值。另外，对于 wait (S)，对于 S 的整数值测试 (S≤0) 和对其可能的修改 (S–)，也必须不被中断地执行。</p><h3 id="651-用法"><a class="anchor" href="#651-用法">#</a> 6.5.1 用法</h3><p>通常操作系统区分 <strong>计数信号量</strong>和 <strong>二进制信号量</strong>。计数信号量的值域不受限制，而二进制信号量的值只能为 0 或 1, 有的系统，将二进制信号量成为 <strong>互斥锁</strong>。<br>由于二进制信号量是互斥的，因而可以将其应用于处理多进程的临界区问题：这 n 个进程共享信号量 mutex，初始值 1。结构如下</p><pre><code>do
&#123;
  wait(mutex);
    //critical section
  signal(mutex);
    //remainder section
&#125;while(TRUE);
</code></pre><p>计数信号量可以用来控制访问具有若干个实例的某种资源。该信号量初始化为可用资源的数量。当每个进程需要使用资源时，需要对该信号量执行 wait () 操作。当进程释放资源时，需要对该信号执行 signal () 操作。</p><p>可以用信号量来解决各种同步问题。如先执行 Pi 的 S1 语句，然后再执行 Pj 的 S2 语句，可以通向一个信号量，初始化为 0。<br>进程 P1 中插入语句：</p><pre><code>S1;
signal(synch);
</code></pre><p>在进程 P2 中插入语句：</p><pre><code>wait(synch);
S2;
</code></pre><p>因为初始化 synch 为 0，P2<br>只有在 P1 调用 signal (synch)，即 (S1) 之后，才会执行 S2。</p><h3 id="652-实现"><a class="anchor" href="#652-实现">#</a> 6.5.2 实现</h3><p>信号量的主要缺点是要求 <strong>忙等待</strong>（busy waiting）。即在进入代码段中连续地循环。忙等待浪费了 CPU 时钟，这种类型的信号量也称为 <strong>自旋锁</strong>（spinlock），这是因为进程在其等待锁的时还在运行 (自旋锁有其优点，进程在等待锁时不进行上下文切换，而上下文切换可能需要花费相当长的时间。因此如果锁占用的时间短，那么锁就有用了，自旋锁常用于多处理器系统中，这样一个线程在一个处理器自旋时，另一线程可在另一个处理器上在其临界区内执行).</p><p>为克服这一缺点，修改 wait () 和 signal () 的定义，信号量值不为正时，不是忙等而是 <strong>阻塞</strong>自己，阻塞操作将一个进程放入到与信号量相关的等待队列中，并将该进程的状态切换成等待状态，接着，控制转到 CPU 调度程序，以选择另一个进程来执行，从而使 CPU 占用率变高。</p><p>被阻塞在等待信号Ｓ上的进程，可以在其他进程执行 signal () 的时候操作之后重新被执行，该进程的重新执行是通过 wakeup () 操作来进行的将进程从等待状态切换到就绪状态。接着进程被放到就绪队列中。</p><p>因而将信号量定义为如下：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token keyword">int</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">process</span> <span class="token operator">*</span>list<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span> semaphore<span class="token punctuation">;</span></pre></td></tr></table></figure><p>每个信号量都有一个整型值和一个进程链表，当一个进程必须等待信号量时，就加入到进程链表上，操作 signal () 会从等待进程链表中取一个进程以唤醒。</p><p><strong>wait () 实现：</strong></p><pre><code>wait (semaphore *S) &#123;
    S-&gt;value--;
    if (S-&gt;value &lt; 0) &#123;
        add this process to S-&gt;list;
        block(); // 挂起调用它的进程
    &#125;
&#125;
</code></pre><p><strong>signal () 实现：</strong></p><pre><code>signal(semaphore *S) &#123;
    S-&gt;value++;
    if (S-&gt;value &lt;= 0) &#123;
        remove a process P from S-&gt;list;
        wakeup(P); // 重新启动阻塞进程P的执行
    &#125;
&#125;
</code></pre><p>操作 block () 挂起调用他的进程。</p><p>操作 wakeup (P) 重新启动阻塞进程Ｐ的执行。</p><p>这两个操作都是由操作系统作为基本系统调用来提供的。</p><p>在具有忙等的信号量经典定义下，信号量的值绝对不能为负数，但是本实现可能造成信号量为负值。 <strong>如果信号量为负值，那么其绝对值就是等待该信号量的进程的个数。</strong></p><p>等待进程的链表可以利用进程控制块 PCB 中的一个链接域来加以轻松实现。即每个信号量包括一个整型值和一个 PCB 链表的指针。</p><p>信号量的关键之处是它们原子的执行。必须确保没有两个进程能同时对一个信号量进行操作，在单处理器情况下，可以在执行 wait () 和 signal () 的时候简单的关闭中断，保证只有当前进程进行。</p><p>多处理器下，若禁止所有 CPU 的中断，则会严重影响性能，SMP 系统必须提供其他加锁技术（如自旋锁），以确保 wait () 与 signal () 可原子地执行。</p><h3 id="653-死锁与饥饿"><a class="anchor" href="#653-死锁与饥饿">#</a> <strong>6.5.3 死锁与饥饿</strong></h3><p>具有等待队列的信号量的实现可能会导致这样的情况：</p><p>两个或多个进程无限地等待一个事件，而该事件只能由这些等待进程之一来产生。这里的事件是 signal () 操作的执行。当出现这样的状态时，这些进程就称为死锁（deadlocked）。</p><p>例如，一个由 P1<br>和 P2 组成的系统，每个都访问共享的信号量Ｓ和Ｑ，Ｓ和Ｑ初值均为１。</p><p>P0:</p><pre><code>wait(S);
wait(Q);
//......

signal(S);
signal(Q);
</code></pre><p>P1:</p><pre><code>wait(Q);
wait(S);
//......

signal(Q);
signal(S);
</code></pre><p>假设，P0 执行 wait (S)，接着 P1 执行 wait (Q)，P0 再执行 wait (Q) 时，必须等待，直到 P1 执行 signal (Q)，而此时 P1 也在等待 P0 执行 signal (S)，两个操作都不能进行，P0 和 P1 就死锁了。</p><p>与死锁相关的另一个问题是 <strong>无限期阻塞（indefinite blocking）或饥饿</strong>（starvation）：即进程在信号量内无限期等待。</p><p>举个例子来理解死锁与饥饿的区别：</p><p>死锁 (deadlock)<br>指的是两个或者两个以上的进程相互竞争系统资源，导致进程永久阻塞。</p><p>例如：</p><p>1、桌子上有慢慢一桌子的美食，但是只有一双筷子。<br>2、甲拿了一根，然后在找另一根。<br>3、乙拿了一根，然后也在找另一根。<br>4、因为他们都掌握了对方必需的资源，导致最后他们俩谁都吃不到美食。</p><p>饥饿 (starvation)<br>指的是等待时间已经影响到进程运行，此时成为饥饿现象。如果等待时间过长，导致进程使命已经没有意义时，称之为 &quot;饿死&quot;。</p><p>例如：</p><p>1、小明要告诉妈妈明天开家长会。<br>2、小明妈妈因为工作太忙，在公司加班，没有回家。<br>3、于是第二天，小明的妈妈就错过了家长会。（&quot;饿死&quot;）<br>4、其实小明的妈妈没有出现 &quot;死锁&quot;。只是小明的优先级过低，不如工作重要。</p><h2 id="66-经典同步问题"><a class="anchor" href="#66-经典同步问题">#</a> 6.6 经典同步问题</h2><h3 id="661-有限缓存问题生产者消费问题"><a class="anchor" href="#661-有限缓存问题生产者消费问题">#</a> 6.6.1 有限缓存问题 — 生产者消费问题：</h3><p>假设缓冲池有 n 个缓冲项，每个缓冲项能存在一个数据项。信号量 mutex 提供了对缓冲池访问的互斥要求，并初始化为 1。信号量 empty 和 full 分别用来表示空缓冲项和满缓冲项的个数，信号量 empty 初始化为 n；而信号量 full 初始化为 0</p><p>生产者进程结构：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 生产者</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// produce an item in nextp</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// add nextp to buffer</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">signal</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>消费者进程结构：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 消费者</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// r3emove an item from buffer to nextc</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">signal</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// consume the item in nextc</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="662-读者-写者问题"><a class="anchor" href="#662-读者-写者问题">#</a> 6.6.2 读者 - 写者问题</h3><p>只读数据库的进程称为读者；更新（读和写）数据库的称为写者。</p><p>第一读者 - 写者问题：要求没有读者需要保持等待除非已有一个写者已获得允许已使用共享数据库。换句话说，没有读者会因为一个写者在等待而会等待其他读者的完成。</p><p>第二读者 - 写者问题：要求一旦写者就绪，那么写者会尽可能快得执行其写操作。换句话说，如果一个写者等待访问对象，那么不会有新读者开始读操作。</p><p>对于这两个问题的解答可能导致饥饿问题。对第一种情况，写者可能饥饿；对第二种情况，读者可能饥饿。</p><p>对于第一读者－写者问题的解决:</p><p>读者进程共享以下数据结构：</p><pre><code>semaphore mutex, wrt;
int readcount;
</code></pre><p>信号量 mutex 和 wrt 初始化为 1，readcount 初始化为 0，信号量 wrt 为读者和写者进程所共有。信号量 mutex 用于确保在更新变量 readcount 时的互斥。变量 readcount 用来跟踪有多少进程正在读对象。信号量 wrt 供写者作为互斥信号量，它为第一个进入临界区和最后一个离开临界区的读者所使用，而不被其他读者所使用。</p><p>写者进程结构：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 写者进程结构</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">wait</span><span class="token punctuation">(</span>wrt<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// writing is performed</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">signal</span><span class="token punctuation">(</span>wrt<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>读者进程结构：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 读者进程结构</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    readcount<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 当前没有读者，需要等待 / 获取写者互斥</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token function">wait</span><span class="token punctuation">(</span>wrt<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// reading is performed</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    readcount<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 所有读者退出，释放写者互斥</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token function">signal</span><span class="token punctuation">(</span>wrt<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>推广为读写锁。</p><p>在以下情况下最为有用：</p><p>一是，当可以区分哪些进程只需要读共享数据，哪些进程只需要写共享数据；</p><p>二是，当读者进程数比写进程多时。</p><h3 id="663-哲学家进餐问题"><a class="anchor" href="#663-哲学家进餐问题">#</a> <strong>6.6.3 哲学家进餐问题</strong></h3><p>拿起与他相近的两只筷子，一个哲学家一次只能拿起一只筷子，同时有两只筷子时，就能吃，吃完，会放下两只筷子。</p><p>一种简单的方法，每只筷子都用一个信号量来表示。一个哲学家通过执行 wait () 操作试图获取相应的筷子，他会通过执行 signal () 操作以释放相应的筷子。</p><p>共享数据为：semaphore chopstick [5]; 其中所有 chopstick 的元素初始化为 1。</p><p>哲学家 i 的结构：</p><pre><code>do
&#123;
  wait(chopstick[i]);
  wait(chopstick[(i+1)%5]);
  &amp;#x2026;;
  //eat
  &amp;#x2026;;
  signal(chopstick[i]);
  signal(chopstick[(i+1)%5]);
  &amp;#x2026;;
  //think
  &amp;#x2026;;
&#125;while(TRUE);
</code></pre><p>但这种方法会发生死锁，例如，所有哲学家同时饥饿，且同时拿起左边的筷子。</p><p>多种可以解决死锁的方法：<br>①最多只允许 4 个哲学家同时坐在桌子上；<br>②只有两只筷子都可用时才允许一个哲学家拿起它们（他必须在临界区内拿起两只筷子）；<br>③使用非对称解决方法，即技术哲学家先拿起左边的筷子，接着拿起右边的筷子，而偶数哲学家先拿起右边的筷子，接着拿起左边的筷子。</p><h1 id="第七章-死锁"><a class="anchor" href="#第七章-死锁">#</a> 第七章 死锁</h1><blockquote><p>所有申请的资源都被其他等待进程占有，那么该等待进程有可能在无法改变其状态，这种情况称为 <strong>死锁</strong>（deadlock）。</p></blockquote><h2 id="71-系统模型"><a class="anchor" href="#71-系统模型">#</a> 7.1 系统模型</h2><p>进程在使用资源之前必须先申请资源，在使用资源之后要释放资源。进程所申请的资源数量不能超过系统所有资源的总量。</p><p>某系统拥有一定数量的资源，分布在若干竞争进程之间。这些资源可以分成多种类型，每种类型有一定数量的实例。</p><p><strong>在正常操作模式下，进程只能按如下顺序使用资源</strong>：</p><ul><li>①申请：如果申请不能立即被允许，那么申请进程必须等待，直到它获得该资源为止。</li><li>②使用：进程对资源进行操作。</li><li>③释放：进程释放资源</li></ul><p>资源的申请与释放为 <strong>系统调用</strong>。其他资源的申请与释放可以通过信号量的 wait 与 signal 操作或通过互斥锁的获取与释放来完成。因此对于进程和线程的每次使用，操作系统会检查以确保使用进程已经申请并获得了资源。</p><p>系统表记录了每个资源是否空闲或已被分配，分配给了哪个进程。如果进程正在申请的资源正在为其他进程所使用，那么该进程会增加到该资源的等待队列。</p><p><strong>当一组进程的每个进程都在等待一个事件，而这个事件只能由这一组进程的另一个进程所引起，那么这组进程就处于死锁状态</strong>。</p><p>死锁也可设计不同的资源类型。多线程可能因为竞争共享资源而容易产生死锁。</p><h2 id="72-死锁特征"><a class="anchor" href="#72-死锁特征">#</a> 7.2 死锁特征</h2><p>当出现死锁时，进程永远不能完成，并且系统资源被阻碍使用，阻止了其他作业开始执行。</p><h3 id="721-必要条件"><a class="anchor" href="#721-必要条件">#</a> 7.2.1 必要条件</h3><p><strong>如果在一个系统中下面四个条件同时满足，那么会引起死锁。</strong></p><p>（1） 互斥 (mutual exclusion)：至少有一个资源必须处于非共享模式，即一次只有一个进程使用，如果另一个进程申请该资源，那么申请进程必须等到该资源被释放为止。</p><p>（2） 占有并等待 (hold and wait)：一个进程必须占有至少一个资源，并等待另一资源，而该资源为其他进程所占有。</p><p>（3） 非抢占 (no preemption)：资源不能被抢占，即资源只能在进程完成任务后自动释放。</p><p>（4） 循环等待 (circular wait)：有一组等待进程｛P0,P1,P2,P3...,Pn｝,P0 等待的资源被 P1 等待，P１等待的资源被 P2 所占有，......，Pn−1 等待的资源为 Pn 所占有，Pn 所等待的资源被 P0 所占有。</p><p>４个条件必须同时满足才会出现死锁，循环等待条件意味着占有并等待条件，这样四个条件并不完全独立。</p><h3 id="722-资源分配图"><a class="anchor" href="#722-资源分配图">#</a> 7.2.2 资源分配图</h3><p>死锁问题可用称为系统资源分配图的有向图进行更为精确地描述。</p><p>这种图由一个节点集合Ｖ和一个边集合Ｅ组成。节点集合Ｖ可以分成两种类型的节点：</p><p>Ｐ＝｛P1，P2，...，Pn｝（系统活动进程的集合）</p><p>Ｒ＝｛R1，R2，...，Rn｝（系统所有资源的集合）</p><p>Pi→Rj<br>表示进程 Pi 已经申请了资源类型为 Rj 的一个实例，称为申请边</p><p>Rj→Pi<br>表示资源类型 Rj 已经分配给进程 Pi，称为分配边</p><p>如一个分配图的例子如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/1910853272/image/img/202111131635370.png" alt=""></p><p>有一个 R1、R3 的资源，有两个 R2 的资源，有三个 R4 的资源。</p><p><strong>可以证明：</strong></p><ul><li>如果分配图没有环，那么系统就没有进程死锁。如果分配图有环，那么可能存在死锁。</li><li>如果每个类型只有一个实例，环是死锁存在的充分必要条件。不过每个类型不止一个实例，环是死锁的必要条件。</li></ul><p>存在死锁的资源分配图：</p><p><img data-src="https://img-blog.csdnimg.cn/20190326214632949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70" alt=""></p><p>存在环但是没有死锁的资源分配图:</p><p><img data-src="https://img-blog.csdnimg.cn/20190326214641465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="73-死锁处理方法"><a class="anchor" href="#73-死锁处理方法">#</a> 7.3 死锁处理方法</h2><p><strong>有三种方法：</strong></p><ul><li>可使用协议以 <strong>预防或避免</strong>死锁，确保系统不会进入死锁状态。</li><li>可允许系统进入死锁状态，然后检测它，并加以 <strong>修复</strong>。</li><li>可忽略这个问题，认为死锁不可能在系统内发生。</li></ul><p>这里第三种方法为绝大多数操作系统所用，因此应用程序开发人员需要自己来处理死锁。</p><p>为了确保死锁不会发生，系统可以采用死锁预防或死锁避免方案</p><p><strong>死锁预防</strong>（deadlock prevention）是一组方法，以确保至少一个必要条件不成立。这些方法通过限制如何申请资源的方法来预防死锁。</p><p><strong>死锁避免</strong>（deadlock avoidance）要求操作系统事先得到有关进程申请资源和使用资源的额外信息。有了这些额外信息，系统可以确定：对于一个申请，进程是否应等待。为了确定当前申请是允许还是延迟，系统必须考虑可用资源，已经分配给每个进程的资源，每个进程将来申请和释放的资源。</p><p>除此之外，系统还可以提供一个算法来检查系统状态来确定死锁是否发生，并提供另一个算法来从死锁中恢复。</p><p>预防死锁的副作用是降低设备的使用率和系统的吞吐率。</p><p>缺点是低设备使用率和系统吞吐率。</p><h2 id="74-死锁预防deadlock-prevention"><a class="anchor" href="#74-死锁预防deadlock-prevention">#</a> 7.4 死锁预防（deadlock prevention）</h2><blockquote><p>出现死锁有四个必要条件，只要保证至少一个条件不成立，就能预防死锁的发生。</p></blockquote><h3 id="741-互斥"><a class="anchor" href="#741-互斥">#</a> 7.4.1 互斥</h3><p>对于非共享资源，必须要有互斥条件（如打印机）。另一方面，共享资源不要求互斥访问，因此不会涉及死锁（如只读文件）。</p><p>故通常不能通过否定互斥条件来预防死锁，有的资源本身就是非共享的。</p><h3 id="742-占有并等待"><a class="anchor" href="#742-占有并等待">#</a> 7.4.2 占有并等待</h3><p>为了确保占有并等待条件不会在系统内出现，必须保证： <strong>当一个进程申请一个资源时，就不能占有其他资源。</strong></p><p>方法一：可以通过要求申请资源的系统调用在所有其使用的协议是每个进程在执行前申请并获得所有资源。他系统调用之前进行。</p><p>方法二：允许进程在没有资源时才可申请资源，一个进程可申请一些资源并使用它们，然而，在它申请更多其他资源之前，它必须释放其现已分配的所有资源。</p><p><strong>这两种协议有两个主要缺点：</strong></p><p>第一，资源利用率（resource utilization）可能比较低，因为很多资源可能已分配，但长时间没有被使用。</p><p>第二，可能发生饥饿。一个进程如需要多个常用资源，可能会永久等待，比如因为其所需要的资源中至少一个总是分配给其他的进程。</p><h3 id="743-非抢占"><a class="anchor" href="#743-非抢占">#</a> 7.4.3 非抢占</h3><p>为确保这一条件不成立，可使用如下协议：</p><p>即可以抢占，如果一个进程占用资源并申请另一个不能立即分配的资源，那么其现已分配的资源都可被抢占，即这些资源被隐式地释放了。只有当进程获得其原有资源和所申请的新资源时，进程才可以重新执行。</p><p>或者说，如果一个进程申请一些资源，首先检查是否可用，如果可用就分配它们，如果不可用，那么检查这些资源是否已分配给其他等待额外资源的进程。如果是就抢占这些资源，并分配给申请进程。如果资源不可用且也不可被其他等待进程占有，那么申请进程必须等待。当一个进程处于等待时，如果其他进程申请其拥有的资源，那么该进程部分资源可以被抢占。一个进程要重新执行，他必须分配到其所申请的资源，并恢复其在等待时被抢占的资源。</p><p>这个协议通常用于状态可以保存和恢复的资源，如 CPU 寄存器和内存，一般不适用其他资源，如打印机和磁带驱动器。</p><h3 id="744-循环等待"><a class="anchor" href="#744-循环等待">#</a> 7.4.4 循环等待</h3><p>一个确保此条件不成立的方法是：对所有资源类型进行完全排序，且要求每个进程按递增顺序来申请资源。</p><p>设Ｒ＝｛R1，R2，R3，...，Rn｝为资源类型的的集合。为每个资源类型分配一个唯一整数来允许比较两个资源以确定其先后顺序。可定义一个函数Ｆ：R→N , 其中Ｎ是自然数集合，例如：Ｆ（tapedrive）＝1 Ｆ（diskdrive）＝5 Ｆ（printer）＝12</p><p>每个进程只按照递增顺序申请资源，即一个进程开始可以申请任意数量的资源类型为Ｒｉ的实例。之后，当且仅当Ｆ（Rj）&gt;Ｆ（Ri）时，该进程可以申请资源 Rj 的实例。如果需要同一资源类型的多个实例，那么对它们必须一起申请。</p><p>例如，对于以上给定函数，一个进程如果同时需要打印机和磁带驱动器，那么就必须先申请磁带驱动器，再申请打印机。换句话说，要求当一个进程申请资源类型 Rj 时，必须先释放所有 Ri [Ｆ（Ri）&gt;Ｆ（Rj）]</p><p>可以使用反证法证明，使用这两个协议，那么循环等待就不可能成立。</p><p>设计一个完全排序或层析并不能防止死锁，而是要靠应用程序员来按顺序编写程序。另外函数Ｆ应该根据系统内资源使用的正常顺序来定义。例如，由于磁带通常在打印机之前使用，所以定义Ｆ（tapedrive）</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-02-18 14:18:53" itemprop="dateModified" datetime="2022-02-18T14:18:53+08:00">2022-02-18</time> </span><span id="2021/11/11/期末/操作系统概念/" class="item leancloud_visitors" data-flag-title="" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="lzs 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="lzs 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>lzs <i class="ic i-at"><em>@</em></i>Sakura</li><li class="link"><strong>本文链接：</strong> <a href="https://zengshengli775.gitee.io/2021/11/11/%E6%9C%9F%E6%9C%AB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/">https://zengshengli775.gitee.io/2021/11/11/期末/操作系统概念/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/11/11/%E6%9C%9F%E6%9C%AB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/" itemprop="url" rel="prev" data-background-image="http:&#x2F;&#x2F;www.dmoe.cc&#x2F;random.php?561819" title="操作系统概念笔记"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 期末</span><h3>操作系统概念笔记</h3></a></div><div class="item right"><a href="/2022/02/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/" itemprop="url" rel="next" data-background-image="http:&#x2F;&#x2F;www.dmoe.cc&#x2F;random.php?930853" title="机器学习资料"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 机器学习</span><h3>机器学习资料</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">操作系统概念 学习笔记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AF%BC%E8%AE%BA"><span class="toc-number">2.</span> <span class="toc-text">第一章、导论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#111-%E7%94%A8%E6%88%B7%E8%A7%86%E8%A7%92"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1.1 用户视角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#112-%E7%B3%BB%E7%BB%9F%E8%A7%86%E8%A7%92"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.1.2 系统视角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#113-%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.1.3 定义操作系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E7%BB%87"><span class="toc-number">3.</span> <span class="toc-text">1.2 计算机系统组织</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.</span> <span class="toc-text">1.2.1 计算机系统操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#122-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.2.2 存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#123-io%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.2.</span> <span class="toc-text">1.2.3 I&#x2F;O 结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">1.3 计算机系统体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">1.4 操作系统结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.</span> <span class="toc-text">1.5 操作系统操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#151-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%8C%E9%87%8D%E6%A8%A1%E5%BC%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.1.</span> <span class="toc-text">1.5.1 操作系统的双重模式操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#152-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">3.4.2.</span> <span class="toc-text">1.5.2 定时器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">第二章 操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.1.</span> <span class="toc-text">2.1 操作系统服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="toc-number">4.2.</span> <span class="toc-text">2.2 操作系统的用户界面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8system-call"><span class="toc-number">4.3.</span> <span class="toc-text">2.3 系统调用（System Call）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">2.4 系统调用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E5%88%86%E7%B1%BB"><span class="toc-number">4.5.</span> <span class="toc-text">2.5 系统程序分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.6.</span> <span class="toc-text">2.6 操作系统设计和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">4.6.0.1.</span> <span class="toc-text">设计目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%BA%E5%88%B6mechanism%E5%92%8C%E7%AD%96%E7%95%A5policy"><span class="toc-number">4.6.0.2.</span> <span class="toc-text">机制（mechanism）和策略（policy）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.6.0.3.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">4.7.</span> <span class="toc-text">2.7 操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#271-%E7%AE%80%E5%8D%95%E7%BB%93%E6%9E%84"><span class="toc-number">4.7.1.</span> <span class="toc-text">2.7.1 简单结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#272-%E5%88%86%E5%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">4.7.2.</span> <span class="toc-text">2.7.2 分层方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#273-%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-number">4.7.3.</span> <span class="toc-text">2.7.3 微内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#274-%E6%A8%A1%E5%9D%97"><span class="toc-number">4.7.4.</span> <span class="toc-text">2.7.4 模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">4.8.</span> <span class="toc-text">2.8 虚拟机</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">第三章 进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">3.1 进程概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#311-%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">3.1.1 进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#312-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">5.1.2.</span> <span class="toc-text">3.1.2 进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#313-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97pcb"><span class="toc-number">5.1.3.</span> <span class="toc-text">3.1.3 进程控制块（PCB）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">5.2.</span> <span class="toc-text">3.2、进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#321-%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97"><span class="toc-number">5.2.1.</span> <span class="toc-text">3.2.1 调度队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322-%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">3.2.2 调度程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#323-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">5.2.3.</span> <span class="toc-text">3.2.3 上下文切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">5.3.</span> <span class="toc-text">3.3 进程操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#331-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">5.3.1.</span> <span class="toc-text">3.3.1 进程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#unix-%E4%B8%AD"><span class="toc-number">5.3.1.0.1.</span> <span class="toc-text">UNIX 中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#windows-%E4%B8%AD"><span class="toc-number">5.3.1.0.2.</span> <span class="toc-text">Windows 中</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#332-%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">5.3.2.</span> <span class="toc-text">3.3.2 进程终止</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">5.4.</span> <span class="toc-text">3.4 进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#341%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.4.1.</span> <span class="toc-text">3.4.1 共享内存系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#342%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.4.2.</span> <span class="toc-text">3.4.2 消息传递系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E5%90%8D"><span class="toc-number">5.4.2.0.1.</span> <span class="toc-text">命名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">5.4.2.0.2.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%86%B2"><span class="toc-number">5.4.2.0.3.</span> <span class="toc-text">缓冲</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E6%9C%BA-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F%E9%80%9A%E4%BF%A1"><span class="toc-number">5.4.3.</span> <span class="toc-text">客户机 - 服务器系统通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#socket"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">Socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">远程过程调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.5.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">第四章 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">4.1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#411-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">6.1.1.</span> <span class="toc-text">4.1.1 多线程编程的优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">4.2 多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#421-%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.2.1.</span> <span class="toc-text">4.2.1 多对一模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#422-%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.2.2.</span> <span class="toc-text">4.2.2 一对一模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-2"><span class="toc-number">7.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#423-%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.0.1.</span> <span class="toc-text">4.2.3 多对多模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-3"><span class="toc-number">8.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-4"><span class="toc-number">9.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E7%BA%BF%E7%A8%8B%E5%BA%93"><span class="toc-number">9.1.</span> <span class="toc-text">4.3 线程库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-number">9.2.</span> <span class="toc-text">4.4 多线程问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#441-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8fork%E5%92%8Cexec"><span class="toc-number">9.2.1.</span> <span class="toc-text">4.4.1 系统调用 fork () 和 exec ()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#442-%E5%8F%96%E6%B6%88"><span class="toc-number">9.2.2.</span> <span class="toc-text">4.4.2 取消</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#443-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-number">9.2.3.</span> <span class="toc-text">4.4.3 信号处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#444-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">9.2.4.</span> <span class="toc-text">4.4.4 线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#445-%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE"><span class="toc-number">9.2.5.</span> <span class="toc-text">4.4.5 线程特定数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-cpu%E8%B0%83%E5%BA%A6"><span class="toc-number">10.</span> <span class="toc-text">第五章 CPU 调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">10.1.</span> <span class="toc-text">5.1 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#511-cpu-io-%E5%8C%BA%E9%97%B4%E5%91%A8%E6%9C%9F"><span class="toc-number">10.1.1.</span> <span class="toc-text">5.1.1 CPU-I&#x2F;O 区间周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#512-cpu%E7%A8%8B%E5%BA%8F%E8%B0%83%E5%BA%A6"><span class="toc-number">10.1.2.</span> <span class="toc-text">5.1.2 CPU 程序调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#513-%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A6"><span class="toc-number">10.1.3.</span> <span class="toc-text">5.1.3 抢占调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#514-%E5%88%86%E6%B4%BE%E7%A8%8B%E5%BA%8F"><span class="toc-number">10.1.4.</span> <span class="toc-text">5.1.4 分派程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="toc-number">10.2.</span> <span class="toc-text">5.2 调度准则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">10.3.</span> <span class="toc-text">5.3 调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#531-%E5%85%88%E5%88%B0%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6first-comefirst-served-scheduling"><span class="toc-number">10.3.1.</span> <span class="toc-text">5.3.1 先到先服务调度 (First-Come，First-Served scheduling)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#532-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6shortest-job-first-schedulingsjf"><span class="toc-number">10.3.2.</span> <span class="toc-text">5.3.2 最短作业优先调度 (shortest-job-first scheduling,SJF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#533-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6priority-scheduling-algorithm"><span class="toc-number">10.3.3.</span> <span class="toc-text">5.3.3 优先级调度 (priority scheduling algorithm)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#534-%E8%BD%AE%E8%BD%AC%E6%B3%95%E8%B0%83%E5%BA%A6round-robinrr"><span class="toc-number">10.3.4.</span> <span class="toc-text">5.3.4 轮转法调度 (round-robin,RR)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#535-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6multilevel-queue-scheduling"><span class="toc-number">10.3.5.</span> <span class="toc-text">5.3.5 多级队列调度 (Multilevel Queue Scheduling)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">11.</span> <span class="toc-text">第六章 进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E8%83%8C%E6%99%AF"><span class="toc-number">11.1.</span> <span class="toc-text">6.1 背景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E4%B8%B4%E7%95%8C%E5%8C%BAcritical-section"><span class="toc-number">11.1.1.</span> <span class="toc-text">6.2 临界区（critical section）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-peterson%E7%AE%97%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text">6.3 Peterson 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E7%A1%AC%E4%BB%B6%E5%90%8C%E6%AD%A5"><span class="toc-number">11.3.</span> <span class="toc-text">6.4 硬件同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore"><span class="toc-number">11.4.</span> <span class="toc-text">6.5 信号量 (semaphore)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#651-%E7%94%A8%E6%B3%95"><span class="toc-number">11.4.1.</span> <span class="toc-text">6.5.1 用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#652-%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.4.2.</span> <span class="toc-text">6.5.2 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#653-%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF"><span class="toc-number">11.4.3.</span> <span class="toc-text">6.5.3 死锁与饥饿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">11.5.</span> <span class="toc-text">6.6 经典同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#661-%E6%9C%89%E9%99%90%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E9%97%AE%E9%A2%98"><span class="toc-number">11.5.1.</span> <span class="toc-text">6.6.1 有限缓存问题 — 生产者消费问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#662-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">11.5.2.</span> <span class="toc-text">6.6.2 读者 - 写者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#663-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">11.5.3.</span> <span class="toc-text">6.6.3 哲学家进餐问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%AD%BB%E9%94%81"><span class="toc-number">12.</span> <span class="toc-text">第七章 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">12.1.</span> <span class="toc-text">7.1 系统模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E6%AD%BB%E9%94%81%E7%89%B9%E5%BE%81"><span class="toc-number">12.2.</span> <span class="toc-text">7.2 死锁特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#721-%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">12.2.1.</span> <span class="toc-text">7.2.1 必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#722-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-number">12.2.2.</span> <span class="toc-text">7.2.2 资源分配图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">12.3.</span> <span class="toc-text">7.3 死锁处理方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2deadlock-prevention"><span class="toc-number">12.4.</span> <span class="toc-text">7.4 死锁预防（deadlock prevention）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#741-%E4%BA%92%E6%96%A5"><span class="toc-number">12.4.1.</span> <span class="toc-text">7.4.1 互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#742-%E5%8D%A0%E6%9C%89%E5%B9%B6%E7%AD%89%E5%BE%85"><span class="toc-number">12.4.2.</span> <span class="toc-text">7.4.2 占有并等待</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#743-%E9%9D%9E%E6%8A%A2%E5%8D%A0"><span class="toc-number">12.4.3.</span> <span class="toc-text">7.4.3 非抢占</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#744-%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85"><span class="toc-number">12.4.4.</span> <span class="toc-text">7.4.4 循环等待</span></a></li></ol></li></ol></li></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="lzs" data-src="/images/avatar.jpg"><p class="name" itemprop="name">lzs</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">32</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">12</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">36</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3plbmdzaGVuZ2xpNzc1" title="https:&#x2F;&#x2F;github.com&#x2F;zengshengli775"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9senMtNDg=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;lzs-48"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE4ODAwNzc0NjY=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1880077466"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9naXRlZS5jb20vemVuZ3NoZW5nbGk3NzUvemVuZ3NoZW5nbGk3NzU=" title="https:&#x2F;&#x2F;gitee.com&#x2F;zengshengli775&#x2F;zengshengli775"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/11/11/%E6%9C%9F%E6%9C%AB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/02/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%9A%E5%AE%A2/" title="分类于 博客">博客</a></div><span><a href="/2021/08/11/%E5%8D%9A%E5%AE%A2/Hexo%E5%8D%9A%E5%AE%A2%E5%86%99%E6%96%87%E7%AB%A0/" title="Hexo博客写文章">Hexo博客写文章</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="分类于 数据结构与算法">数据结构与算法</a></div><span><a href="/2021/11/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" title="数据结构与算法基础">数据结构与算法基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="分类于 机器学习">机器学习</a></div><span><a href="/2022/02/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/" title="机器学习资料">机器学习资料</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" title="分类于 实用技巧">实用技巧</a></div><span><a href="/2021/08/25/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/Mac%20VScode%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="Mac VScode快捷键">Mac VScode快捷键</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%9A%E5%AE%A2/" title="分类于 博客">博客</a></div><span><a href="/2021/08/11/%E5%8D%9A%E5%AE%A2/%E8%BD%AC%E8%BD%BD%E5%8D%9A%E5%AE%A2%E6%96%B9%E6%B3%95/" title="转载博客方法">转载博客方法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%A8%B1%E4%B9%90/" title="分类于 娱乐">娱乐</a></div><span><a href="/2021/08/10/%E5%A8%B1%E4%B9%90/%E5%A8%B1%E4%B9%90%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB/" title="娱乐网站汇总">娱乐网站汇总</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="分类于 编程基础">编程基础</a></div><span><a href="/2021/08/11/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/" title="编程学习资料">编程学习资料</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/" title="分类于 学习工具">学习工具</a></div><span><a href="/2021/09/22/%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/%E4%B8%AD%E6%96%87PDF%E7%94%B5%E5%AD%90%E4%B9%A6%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E4%B9%A6%E7%AD%BE/" title="中文PDF电子书自动添加书签">中文PDF电子书自动添加书签</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="分类于 编程基础">编程基础</a></div><span><a href="/2021/10/01/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" title="C++核心编程">C++核心编程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" title="分类于 实用技巧">实用技巧</a></div><span><a href="/2021/08/29/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/Apple%20Music%E4%BD%BF%E7%94%A8/" title="Apple Music使用">Apple Music使用</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">lzs @ Sakura</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">289k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:23</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/11/11/期末/操作系统概念/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->