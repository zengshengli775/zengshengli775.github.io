<!-- build time:Tue Oct 05 2021 22:55:23 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><meta name="referrer" content="no-referrer"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakura" href="https://zengshengli775.gitee.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakura" href="https://zengshengli775.gitee.io/atom.xml"><link rel="alternate" type="application/json" title="Sakura" href="https://zengshengli775.gitee.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="操作系统"><link rel="canonical" href="https://zengshengli775.gitee.io/2021/09/29/%E6%9C%9F%E6%9C%AB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%20%E7%AC%94%E8%AE%B0/"><title>操作系统概念 笔记 - 期末 | Sakura = Sakura = 我以为18岁之后是19岁，19岁之后是18岁，20岁永远都不会到来 。</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">操作系统概念 笔记</h1><div class="meta"><span class="item" title="创建时间：2021-09-29 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-09-29T00:00:00+08:00">2021-09-29</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>47k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>43 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Sakura</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="http://www.dmoe.cc/random.php?455630"></li><li class="item" data-background-image="http://www.dmoe.cc/random.php?317848"></li><li class="item" data-background-image="http://www.dmoe.cc/random.php?863633"></li><li class="item" data-background-image="http://www.dmoe.cc/random.php?862501"></li><li class="item" data-background-image="http://www.dmoe.cc/random.php?476771"></li><li class="item" data-background-image="http://www.dmoe.cc/random.php?848312"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E6%9C%9F%E6%9C%AB/" itemprop="item" rel="index" title="分类于 期末"><span itemprop="name">期末</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://zengshengli775.gitee.io/2021/09/29/%E6%9C%9F%E6%9C%AB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%20%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="lzs"><meta itemprop="description" content="我以为18岁之后是19岁，19岁之后是18岁，20岁永远都不会到来 。, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakura"></span><div class="body md" itemprop="articleBody"><h1 id="第一部分-概论"><a class="anchor" href="#第一部分-概论">#</a> 第一部分 概论</h1><h2 id="第-1-章-导论"><a class="anchor" href="#第-1-章-导论">#</a> 第 1 章 导论</h2><p>操作系统是管理计算机硬件的程序， 为应用程序提供基础， 并且充当计算机硬件和计算机用户的中介。</p><p>计算机系统大致分为 4 个部分：</p><ul><li>计算机硬件</li><li>操作系统</li><li>系统程序与应用程序</li><li>用户</li></ul><h3 id="计算机系统操作"><a class="anchor" href="#计算机系统操作">#</a> 计算机系统操作</h3><p>计算机开始运行的时候，通常需要运行一个初始化程序 / 引导程序 (bootstrap program)，通常位于 ROM 或 EEPROM 中，称为计算机硬件中的固件。</p><p>它负责初始化系统中的所有部分，包括：CPU 寄存器， 设备控制器， 内存内容。它必须知道如果装入系统并开始执行系统，定位操作系统内核并把他装入内存，然后操作系统就开始初始化。</p><h3 id="中断"><a class="anchor" href="#中断">#</a> 中断</h3><p>事件的发生通常通过硬件或软件中断 (interrupt) 来表示，硬件可以随时通过系统总线向 CPU 发出信号，触发中断，而软件通过执行特别操作如系统调用 (system call)/ 监视器调用 (monitor call)</p><p>中断是计算机结构的重要组成部分。中断必须将控制转移到合适的中断处理程序，简单的方法就是调用一个通用的子程序检查中断信息，然后调用对应的中断处理程序。</p><p>也可以使用中断处理子程序的指针表，间接地调用，这样就不需要经过其他的中间子程序。通常指针表处于低地址内存，包括了各种设备的中断处理子程序的地址，地址的数组或中断向量 (interrupt vector) 可以通过唯一设备索引号来提供子程序地址。</p><p>中断程序必须负责恢复中断前的状态。</p><h3 id="存储结构"><a class="anchor" href="#存储结构">#</a> 存储结构</h3><p>典型指令执行周期</p><ul><li>从内存中获取指令， 保存在指令寄存器 (instruction register)</li><li>指令被解码，并可能导致从内存获取操作数或将操作数保存在内部寄存器中</li><li>执行指令</li></ul><p>理想情况下， 程序和数据都永久留在内存中，但是这是不可能的，因为</p><ul><li>内存太小</li><li>内存是易失性存储设备</li></ul><p>所以需要辅存 (secondary storage)， 如磁盘 (magnetic disk)， SSD</p><p>存储设备层次：(估计比较老的了)</p><ul><li>寄存器</li><li>高速缓存</li><li>主存</li><li>电子磁盘</li><li>磁盘</li><li>光盘</li><li>磁带</li></ul><h3 id="io-结构"><a class="anchor" href="#io-结构">#</a> I/O 结构</h3><p>通用计算机系统由一个 CPU 和多个设备控制器组成。通过共同的总线连接起来，每个设备控制器负责特定类型的设备，可有多个设备与其相连。</p><p>SCSI (small computer system interface) 控制器可以有 7 个或更多的设备相连。</p><p>设备控制器</p><ul><li>维护一定量的本地缓冲存储和一组特定用途的寄存器</li><li>复制在其控制的外部设备与本地缓冲存储之间进行数据传递</li><li>通常每个设备控制器都有一个设备驱动程序</li></ul><p>I/O 中断驱动 (适合少量的数据)</p><ul><li>设备驱动程序在设备控制器中装载适当的寄存器</li><li>设备控制器检查寄存器状态决定操作</li><li>控制器开始向本地缓冲区传输数据</li><li>设备控制器通过中断通知设备驱动程序已完成操作</li><li>设备驱动程序返回对系统的控制。</li></ul><p>DMA (direct memory access) 直接内存访问</p><p>设备直接写入内存而不需要 CPU 的干预，每一块只产生一个中断。</p><p>交换使得各个部件并发对话而不是在总线上争夺事件，更加地高效</p><h3 id="计算机系统体系结构"><a class="anchor" href="#计算机系统体系结构">#</a> 计算机系统体系结构</h3><ul><li><p>单处理器系统</p><ul><li>只有一个通用 CPU</li><li>还包含其他特定目的微处理器， 用来克服主 CPU 超载问题</li></ul></li><li><p>多处理器系统 (并行系统 Parallel system, 紧耦合系统 tightly coupled system)</p><ul><li>拥有多个紧密通信的 CPU，共享计算机总线，时钟，内存和外设</li></ul><p>优点：</p><ul><li>增加吞吐量</li><li>规模经济</li><li>增加可靠性</li></ul></li></ul><p>计算机系统不断增加的可靠性是很关键的，这种能提供与正常工作的硬件成正比的服务的能力称为<strong>适度退化</strong> (graceful degradation)。超出适度退化的能力被称为容错 (fault tolerant)</p><p>多处理器系统主要分为</p><p>非对称多处理 (asymmetric multiprocessing) ： 主从处理器</p><p>对称多处理 (symmetric multiprocessing， SMP)</p><p>概念： 刀片服务器 (blade server) 每个刀片处理器独立启动并运行各自的系统</p><p><strong>集群系统</strong>：</p><p>由两个或多个独立的系统耦合起来的</p><p>通过局域网连接或更快的内部连接 (InfiniBand)</p><p>用途： 提供高可用性 (high availability) 服务</p><p>分类：对称与非对称</p><p>非对称集群 (asymmetric clustering) 中， 一台机器处于热备份状态 (hot standby mode)，另一台运行程序。</p><p>对称集群 (symmetric clustering)，两个或多个主机都运行程序并互相监视。</p><p>还有并行集群和 WAN 集群。</p><p>并行集群中通常需要分布式锁管理器 (distributed lock manager， DLM)</p><h3 id="操作系统结构"><a class="anchor" href="#操作系统结构">#</a> 操作系统结构</h3><p>分时操作系统、多道程序设计</p><p>进程 (process): 装到内存并执行的程序</p><p>作业调度 (job scheduling)： 在储存在磁盘作业池 (job pool) 中与主存中的作业做出决策和安排</p><p>CPU 调度 (CPU scheduling)： 多个任务同时执行</p><p>在分时操作系统中，为了保证合理的相应时间，就需要通过交换来得到。通常使用虚拟内存 (virtual memory) 实现。</p><h3 id="操作系统操作"><a class="anchor" href="#操作系统操作">#</a> 操作系统操作</h3><p>现代操作系统通常是由<strong>中断</strong>驱动的。</p><p>操作系统的合理设计必须确保错误程序 (或恶意程序) 不会造成其他程序执行错误。</p><h4 id="双重模式操作"><a class="anchor" href="#双重模式操作">#</a> 双重模式操作</h4><p>区分操作系统代码和用户自定义代码的执行，通常提供硬件支持以允许区分各种执行模式 (在计算机硬件增加一个模式位 (mode bit) 来区分)</p><ul><li>用户模式 (user mode)</li><li>内核模式：监督程序模式 (monitor mode)[也称为管理模式 (supervisor mode)]、系统模式 (system mode) 或特权模式 (privileged mode)</li></ul><p>只要操作系统获得了对计算机的控制，就处于内核模式。</p><p>某些特权指令 (privileged instruction) 只能在内核模式执行。</p><p>特权指令：可以引起损害的机器指令，如切换到用户模式、I/O 的控制、定时器的管理和中断管理</p><p>系统调用通常采用陷阱到中断向量中的一个指定位置的方式。</p><h4 id="定时器"><a class="anchor" href="#定时器">#</a> 定时器</h4><p>确保操作系统维持对 CPU 的控制，防止用户程序陷入死循环不返回控制权，通常使用定时器 (timer) 定时中断。</p><h3 id="进程管理"><a class="anchor" href="#进程管理">#</a> 进程管理</h3><p>进程：处于执行中的程序</p><p>需要一定的资源</p><p>程序本身不是进程，程序时被动的实体。</p><p>单线程进程具有一个<strong>程序计数器</strong>来明确下一个执行的指令，这样程序的执行必须时连续的。</p><p>进程时系统工作的单元。系统由多个进程组成，其中一些事操作系统进程，其他是用户进程。</p><p>操作系统需要负责：</p><ul><li>创建和删除用户进程和系统进程</li><li>挂起和重启进程</li><li>提供进程同步机制</li><li>提供进程通讯机制</li><li>提供死锁处理机制</li></ul><h3 id="内存管理"><a class="anchor" href="#内存管理">#</a> 内存管理</h3><p>内存是现代计算机操作系统的中心，是 CPU 和 I/O 设备共同快速访问的数据仓库，通常也是 CPU 可以直接寻址和访问的唯一大容量存储器。</p><p>操作系统负责下列有关的内存管理的活动：</p><ul><li>记录内存的哪部分正在被使用和被谁使用</li><li>当有内存空间是，决定哪些进程可以装入内存</li><li>根据需要分配和释放内存空间</li></ul><h3 id="存储管理"><a class="anchor" href="#存储管理">#</a> 存储管理</h3><h4 id="文件系统管理"><a class="anchor" href="#文件系统管理">#</a> 文件系统管理</h4><p>操作系统负责：</p><ul><li>创建和删除文件</li><li>创建和删除目录来组织文件</li><li>提供操作文件和目录的原语</li><li>将文件映射到二级存储上</li><li>在稳定存储介质上备份文件</li></ul><h4 id="大容量存储器管理"><a class="anchor" href="#大容量存储器管理">#</a> 大容量存储器管理</h4><p>操作系统负责：</p><ul><li>空闲空间管理</li><li>存储空间分配</li><li>硬盘调度</li></ul><h4 id="高速缓存"><a class="anchor" href="#高速缓存">#</a> 高速缓存</h4><p>由于高速缓存的大小有限，因此高速缓存管理 (cache management) 的设计就显得十分地重要。</p><p>高速缓存的大小和置换策略的仔细选择可以极大地提高性能.</p><p>高速缓存需要解决<strong>高速缓存一致性</strong> (cache coherency), 这通常是硬件问题。以确保每个进程都得到最近已更新的值</p><h4 id="io-系统"><a class="anchor" href="#io-系统">#</a> I/O 系统</h4><p>操作系统的目的之一： 对用户隐藏具体硬件设备的特性。</p><p>而 I/O 子系统也对操作系统隐藏一些 I/O 设备的特性。只有设备驱动才知道特性。</p><h3 id="保护和安全"><a class="anchor" href="#保护和安全">#</a> 保护和安全</h3><p>保护： 一种控制进程或用户对计算机系统资源的访问的机制</p><p>安全： 防止系统不受外部或内部攻击</p><h3 id="分布式系统"><a class="anchor" href="#分布式系统">#</a> 分布式系统</h3><p>网络， 两个或多个系统之间的通讯路径</p><p>一个网络协议只简单地需要一个接口设备，加上管理他的驱动程序以及按网络协议处理数据的软件</p><p>根据<strong>节点间的距离</strong>来分，网络可以分为</p><ul><li>局域网 (local-area network， LAN)</li><li>广域网 (wide-area network， WAN)</li><li>城域网 (metropolitan-area network，MAN)</li><li>小域网 (small-area network， SAN)</li></ul><p>网络操作系统 (network operating system) 提供了比网络连接更进一步的网络和分布式系统的概念</p><h3 id="专用系统"><a class="anchor" href="#专用系统">#</a> 专用系统</h3><ul><li>实时嵌入式系统</li><li>多媒体系统</li><li>手持系统</li></ul><h3 id="计算环境"><a class="anchor" href="#计算环境">#</a> 计算环境</h3><h4 id="传统计算"><a class="anchor" href="#传统计算">#</a> 传统计算</h4><h4 id="客户机-服务器计算"><a class="anchor" href="#客户机-服务器计算">#</a> 客户机 - 服务器计算</h4><ul><li>计算服务器系统</li><li>文件服务器系统</li></ul><h4 id="对等计算"><a class="anchor" href="#对等计算">#</a> 对等计算</h4><p>对等 (P2P) 系统模式</p><h4 id="基于-web-的计算"><a class="anchor" href="#基于-web-的计算">#</a> 基于 Web 的计算</h4><h2 id="第-2-章-操作系统结构"><a class="anchor" href="#第-2-章-操作系统结构">#</a> 第 2 章 操作系统结构</h2><h3 id="操作系统服务"><a class="anchor" href="#操作系统服务">#</a> 操作系统服务</h3><p>操作系统提供给用户的常用函数：</p><ul><li>用户界面 (user interface, UI)：<ul><li>命令行界面 (command-line interface, CLI)</li><li>批界面 (batch interface)，不常见</li><li>图形用户界面 (graphical user interface, GUI)</li></ul></li><li>程序执行</li><li>I/O 操作</li><li>文件系统操作</li><li>通信： 一个进程与另一个进程进行交换信息，可以通过<strong>共享内存</strong>或<strong>信息交换</strong>来实现</li><li>错误检测</li></ul><p>确保系统高效运行的函数：</p><ul><li>资源分配：<ul><li>如，CPU 周期， 内存，文件储存：需要特别的分配代码</li><li>如， I/O 设备：只需要通用的请求和释放代码</li></ul></li><li>统计 (accounting)</li><li>保护和安全</li></ul><h3 id="操作系统的用户界面"><a class="anchor" href="#操作系统的用户界面">#</a> 操作系统的用户界面</h3><h4 id="命令解释程序command-interpreters"><a class="anchor" href="#命令解释程序command-interpreters">#</a> 命令解释程序 (Command Interpreters)</h4><p>获取并执行用户指定的下一条命令</p><p>有两种常用的方法:</p><ul><li>命令解释程序本身包含代码以执行这些命令</li><li>由系统程序实现绝大多数命令，命令解释程序只需要调用</li></ul><h4 id="图形用户界面graphical-user-interfaces"><a class="anchor" href="#图形用户界面graphical-user-interfaces">#</a> 图形用户界面 (Graphical User Interfaces)</h4><p>提供基于鼠标的窗口和菜单系统作为接口</p><ul><li>Usually mouse, keyboard, and monitor</li><li>Icons represent files, programs, actions, etc</li><li>Various mouse buttons over objects in the interface cause various actions (provide information, options, execute function, open directory (known as a folder)</li><li>Invented at Xerox PARC</li></ul><h3 id="系统调用system-calls"><a class="anchor" href="#系统调用system-calls">#</a> 系统调用 (System Calls)</h3><p>提供了操作系统提供的有效服务界面</p><p>Mostly accessed by programs via a high-level Application Program Interface (API) rather than direct system call use</p><p>程序通过高层应用程序接口访问，而不是直接调用系统的调用</p><p>常用的 API：</p><ul><li>Win32 API</li><li>POSIX API (包括几乎所有 UNIX、Linux 和 Mac OS X)</li><li>Java API</li></ul><p>向系统传递参数的方法：</p><ul><li>通过寄存器</li><li>存在内存的块或表中</li><li>放在或压入堆栈中</li></ul><h3 id="系统调用类型"><a class="anchor" href="#系统调用类型">#</a> 系统调用类型</h3><ul><li>进程控制 Process control<ul><li>end, abort</li><li>load, execute</li><li>create process, terminate process</li><li>get process attributes, set process attributes</li><li>wait for time</li><li>wait event, signal event</li><li>allocate and free memory</li></ul></li><li>文件管理 File management<ul><li>create file, delete file</li><li>open, close</li><li>read, write, reposition (重定位)</li><li>get file attributes, set file attributes</li></ul></li><li>设备管理 Device management<ul><li>request device, release device</li><li>read, write, reposition</li><li>get device attributes, set device attributes</li><li>logically attach or detach devices（逻辑连接或断开设备）</li></ul></li><li>信息维护 Information maintenance<ul><li>get time or date, set time or date</li><li>get system data, set system data</li><li>get process, file, or device attributes</li><li>set process, file, or device attributes</li></ul></li><li>通信 Communications<ul><li>create, delete communication connection</li><li>send, receive message</li><li>transfer status information</li><li>attach or detach remote devices</li></ul></li></ul><h4 id="进程控制"><a class="anchor" href="#进程控制">#</a> 进程控制</h4><ul><li>运行程序需要能正常或非正常地中断其执行 (end 或 abort)</li><li>当发生错误的时候，就会由内存信息转储 (dump of memory) 并产生一个错误信息</li><li>装入和执行另一个程序</li><li>如果新程序终止时控制权返回到现有程序，那么需要保存现有程序的内存映像</li><li>创建新的作业或线程，需要可以控制他的执行，能决定和重置进程或作业的属性 (优先级、最大允许执行时间)</li><li>等待作业或进程执行</li><li>提供转储内存信息的系统调用，帮助调试</li><li>提供程序的时间表</li><li>单任务与多任务系统的控制</li></ul><h4 id="设备管理"><a class="anchor" href="#设备管理">#</a> 设备管理</h4><p>I/O 设备和文件非常相似，在 UNIX 中将这两者合并为<strong>文件 - 设备结构</strong></p><h4 id="通讯"><a class="anchor" href="#通讯">#</a> 通讯</h4><p>通讯模型：</p><ul><li>消息传递模型 (message-passing model)</li><li>共享内存模型 (shared-memory model)</li></ul><h3 id="系统程序"><a class="anchor" href="#系统程序">#</a> 系统程序</h3><p>可以分为：</p><ul><li>文件管理 File manipulation</li><li>状态信息 Status information</li><li>文件修改 File modification</li><li>程序语言支持 Programming language support</li><li>程序装入和执行 Program loading and execution</li><li>通讯 Communications</li><li>应用程序 Application programs</li></ul><h3 id="操作系统设计和实现"><a class="anchor" href="#操作系统设计和实现">#</a> 操作系统设计和实现</h3><h4 id="设计目标"><a class="anchor" href="#设计目标">#</a> 设计目标</h4><p>定义系统的目标和规格</p><p>系统类型：批处理、 分时、 单用户、 多用户、 分布式、 实时、 通用目标</p><p>两个基本类： 用户目标和系统目标</p><h4 id="机制mechanism和策略policy"><a class="anchor" href="#机制mechanism和策略policy">#</a> 机制（mechanism）和策略（policy）</h4><p>区分机制和策略对于灵活性很重要</p><ul><li>机制决定如何做</li><li>策略决定做什么，策略可能随时间或位置而有所改变。</li></ul><h4 id="实现"><a class="anchor" href="#实现">#</a> 实现</h4><p>现代操作系统一般都是用高级语言编写， 如 C 或 C++</p><p>代码编写更快， 更为紧凑，容易理解和调试。</p><p>缺点仅仅为降低了速度和增加了存储要求</p><h3 id="操作系统结构-2"><a class="anchor" href="#操作系统结构-2">#</a> 操作系统结构</h3><h4 id="简单结构"><a class="anchor" href="#简单结构">#</a> 简单结构</h4><p>MS-DOS：并没有很好区分接口和功能层次，应用程序可以直接访问基本的 I/O。</p><p>UNIX： 由内核和系统程序组成， 物理硬件之上和系统调用接口之下的所有部分都是内核， 这一单一的结构使 UNIX 难以增强</p><h4 id="分层方法-layered"><a class="anchor" href="#分层方法-layered">#</a> 分层方法 Layered</h4><p>采用自顶向下方法，可先确定总的功能和特征，再划分模块</p><p>使用分层法来模块化，最底层 (层 0) 是硬件层，最高层 (层 N) 为用户接口</p><p>主要优点： 构造和调试的简单化，每层只能调用较低层的功能和服务。</p><p>主要困难：对层的详细定义较难， 效率稍差。</p><h4 id="微内核-microkernel"><a class="anchor" href="#微内核-microkernel">#</a> 微内核 Microkernel</h4><p>将非基本部分从内核移走</p><p>微内核通常包括最小的进程和内存管理以及通讯功能。</p><p>主要功能：使用户程序和运行在用户空间的各种服务之间进行通讯（利用消息传递）</p><p>好处：</p><ul><li>便于扩充操作系统</li><li>容易移植操作系统到新结构中</li><li>更加可靠（在内核模式下运行的代码少）</li><li>更加安全</li></ul><p>缺点：由于系统功能总开销的增加而导致系统性能的下降</p><h4 id="模块-modules"><a class="anchor" href="#模块-modules">#</a> 模块 Modules</h4><p>模块化的内核：</p><ul><li>使用面向对象 (object-oriented) 方法</li><li>每个核心组件分离</li><li>模块通过接口 (interfaces) 互相调用</li><li>每个模块都作为内核中的可加载模块</li></ul><p>类似于分层，但是更灵活</p><p>Solaris 系统：</p><ul><li>核心内核 core Kernel<ul><li>调度类 scheduling classes</li><li>文件系统 file systems</li><li>可加载的系统调用 loadable system calls</li><li>可执行格式 executable formats</li><li>STREAMS 模块 STREAMS modules</li><li>杂项模块 miscellaneous modules</li><li>设备和总线驱动 device and bug drivers</li></ul></li></ul><p>Mac OS X， 混合结构：</p><ul><li>程序 -&gt;BSD-&gt;Mach</li><li>程序 -&gt;Mach</li></ul><h4 id="虚拟机"><a class="anchor" href="#虚拟机">#</a> 虚拟机</h4><p>提供与基本硬件相同的接口</p><p>虚拟用户模式和虚拟内核模式运行在物理用户模式</p><p>优点：</p><ul><li>不同的系统资源具有完全的保护<ul><li>可以通过共享磁盘或虚拟机网络通讯</li></ul></li><li>研究和开发操作系统</li></ul><p>实例</p><ul><li>VMware<ul><li>将 Intel 80x86 硬件抽象为独立的虚拟机</li></ul></li><li>Java 虚拟机（JVM）<ul><li><strong>类加载器</strong> ： 从 Java 程序和 Java API 中加载编译过的.class 文件</li><li>执行与平台无关的字节码 Java 解释器</li><li>JIT (just-in-time)，可以在第一次调用 Java 方法时，转换为本地机器语言，加快运行速度。</li></ul></li><li>CLR（.Net 的核心，公共语言运行时）</li></ul><h3 id="系统生成"><a class="anchor" href="#系统生成">#</a> 系统生成</h3><p>System generation， SYSGEN</p><p>配置和生成系统</p><p>需要确定的信息：</p><ul><li>CPU</li><li>内存</li><li>可用设备及其具体调用信息</li><li>系统选项的参数</li></ul><p>生成方法（区别在于大小和通用性，以及硬件变化进行修改的方便性）：</p><ul><li>系修改源代码，重新编译</li><li>从预先编译的库中选择模块，将表格连接起来形成操作系统</li><li>由表驱动，在运行时选择适当的模块（大多数现代操作系统）</li></ul><h3 id="系统启动"><a class="anchor" href="#系统启动">#</a> 系统启动</h3><h4 id="过程"><a class="anchor" href="#过程">#</a> 过程</h4><ul><li>加电</li><li>运行初始化程序 (或引导程序，在 ROM 中)<ul><li>初始化 CPU 寄存器，设备控制器到内存</li></ul></li><li>引导程序装入操作系统内核到内存</li><li>操作系统执行第一个进程 init，并等待某些事件发生</li><li>若事件发生，则进入该事件处理程序</li></ul><p>个人计算机中：一个简单的引导程序从磁盘调用一个较复杂的引导程序，再装入内核</p><p>CPU 重置：从 ROM 中，指令寄存器被重新加载，并开始执行。（此时 RAM 处于未知状态）</p><p>有些系统在 ROM 中保存完整的操作系统</p><h1 id="第二部分-进程管理"><a class="anchor" href="#第二部分-进程管理">#</a> 第二部分 进程管理</h1><h2 id="第-3-章-进程"><a class="anchor" href="#第-3-章-进程">#</a> 第 3 章 - 进程</h2><p>操作系统负责进程和线程管理：</p><ul><li>用户进程和系统进程的创建和删除</li><li>进程调度</li><li>提供进程同步机制</li><li>进程通信机制</li><li>进程死锁处理机制</li></ul><h3 id="进程processes"><a class="anchor" href="#进程processes">#</a> 进程（Processes）</h3><p>正在执行的程序，需要一定的资源来完成任务。是大多数系统的工作单元。</p><p>程序本身不是进程，程序只是被动实体，进程是活动实体</p><p>一个程序包括：</p><ul><li>program counter</li><li>stack</li><li>data section</li></ul><p>内存分配：</p><ul><li>栈段：编译时设定，由操作系统分配和释放，保存函数参数和返回地址和局部变量等</li><li>堆区：由程序员分配释放</li><li>数据段：全局区、静态区和常量区</li><li>程序代码段：二进制代码</li></ul><h4 id="进程状态"><a class="anchor" href="#进程状态">#</a> 进程状态</h4><ul><li>New</li><li>Running</li><li>Waiting / Blocked<ul><li>Blocked Suspend</li></ul></li><li>Ready<ul><li>Ready Suspend</li></ul></li><li>Terminated / Exit</li></ul><p>每次只有一个进程可以在一个处理器上运行，但多个进程可处于就绪或等待状态。</p><h4 id="进程控制块"><a class="anchor" href="#进程控制块">#</a> 进程控制块</h4><p>Process control block， PCB， 也称任务控制块（信息的仓库）</p><p>包括：</p><ul><li>进程状态</li><li>程序计数器</li><li>CPU 寄存器</li><li>CPU 调度信息<ul><li>优先级</li><li>调度队列的指针</li><li>其他调度参数</li></ul></li><li>内存管理信息<ul><li>基址</li><li>界限寄存器的值</li><li>页表</li><li>段表</li></ul></li><li>记账信息<ul><li>CPU 时间</li><li>实际使用时间</li><li>时间界限</li><li>记账数据</li><li>作业或进程数量</li></ul></li><li>I/O 状态信息<ul><li>I/O 设备列表</li><li>打开的文件列表</li></ul></li></ul><p>CPU 通过保存 PCB 来进行进程间的切换</p><h4 id="线程"><a class="anchor" href="#线程">#</a> 线程</h4><p>进程可以一次执行多个线程</p><h3 id="进程调度"><a class="anchor" href="#进程调度">#</a> 进程调度</h3><p>选择一个可用的进程到 CPU 上执行</p><h4 id="调度队列"><a class="anchor" href="#调度队列">#</a> 调度队列</h4><p>通常用链表实现。</p><ul><li>作业队列：Job queue - set of all processes in the system</li><li>就绪队列：Ready queue - set of all processes residing in main memory, ready and waiting to execute</li><li>设备队列：Device queue - set of processes waiting for an I/O device<ul><li>等待特定 I/O 设备的进程列表称为设备队列，每个设备都有自己的设备队列。</li></ul></li></ul><p>操作系统在多个队列之间切换</p><p>Linux 中的进程控制块 (PCB) 中是通过结构体表示，包含以下信息</p><ul><li>进程 id</li><li>进程的状态</li><li>调度和内存管理信息</li><li>打开文件列表</li><li>指向父进程和所有子进程的指针</li></ul><p>我们通常使用队列图表示进程调度：</p><ul><li>长方形：队列（就绪队列 / 设备队列）</li><li>圆形：队列服务的资源</li><li>箭头：系统内进程的流向</li></ul><p>当进程分配到 CPU 并执行的时候，可能发生下面几种事件中的一种：</p><ul><li>进程发出一个 I/O 请求，并放入到 I/O 队列中</li><li>进程创建一个新的子进程，并等待其结束</li><li>进程由于中断强制释放 CPU，并被返回就绪队列中</li></ul><h4 id="调度程序scheduler"><a class="anchor" href="#调度程序scheduler">#</a> 调度程序（Scheduler）</h4><p>长期调度程序（long-term scheduler）/ 作业调度程序（job scheduler）：从池中选择进程，<strong>装入内存</strong>准备执行。（创建进程的平均速度必须等于进程离开系统的平均速度，必须<strong>合理分配 I/O 和 CPU 密集</strong>类程序）</p><p>短期调度程序（short-term scheduler）/ CPU 调度程序：准备执行的进程中选择进程，并为之<strong>分配 CPU</strong>。（通常 100ms 执行一次，比较重视速度）</p><p>中期调度程序（medium-term scheduler） 将进程从内存（或 CPU 竞争）中<strong>移出</strong>，之后可以<strong>重新调入</strong>内存（进入就绪队列），并从中断处继续执行，称为<strong>交换（swapping）</strong>。</p><h4 id="上下文切换context-switch"><a class="anchor" href="#上下文切换context-switch">#</a> 上下文切换（Context switch）</h4><p>当发生一个中断时，系统需要保存当前运行在 CPU 中进程的上下文，从而在其处理完能恢复上下文。</p><p>进程上下文用 PCB 表示，包括：CPU 寄存器的值、进程状态、内存管理信息。</p><p>通过执行一个 <strong>状态保存</strong> （state save）保存 CPU 当前状态</p><p>通过执行一个 <strong>状态恢复</strong> （state restore）重新开始运行</p><p>硬件支持：有的处理器提供多组寄存器集合，上下文切换只需改变当前寄存器组的指针</p><h3 id="进程操作"><a class="anchor" href="#进程操作">#</a> 进程操作</h3><h4 id="进程创建"><a class="anchor" href="#进程创建">#</a> 进程创建</h4><p>进程在执行过程中，能通过 <strong>创建进程系统调用</strong> (Create-process system call) 创建多个新进程。</p><p>创建进程成为父进程，新进程成为子进程，形成<strong>进程树</strong>。</p><p><strong>子进程</strong>可能从操作系统直接获取资源，也可能只从父进程获取资源。</p><p><strong>父进程</strong>可能必须在其子进程之间分配资源或共享资源，限制子进程只能使用父进程的资源可以防止创建过多的进程带来的系统超载。</p><p>进程创建的初始化数据（或输入）由父进程传递给子进程。</p><p>创建新进程：</p><ul><li>父进程与子进程<strong>并发</strong>执行</li><li>父进程<strong>等待</strong>，直到某个或全部子进程执行完。</li></ul><p>新进程的地址空间:</p><ul><li><p>子进程是父进程的</p><p>复制品</p><p>(duplicate)</p><ul><li>具有相同的程序和数据</li></ul></li><li><p>子进程装入另一个<strong>新程序</strong></p></li></ul><h5 id="unix-中"><a class="anchor" href="#unix-中">#</a> UNIX 中</h5><p>通过 <code>fork()</code> 创建新进程。新进程通过复制原来进程的地址空间而成。</p><p>对于新进程，系统调用 <code>fork()</code> 返回值为 0，对于父进程，返回值为子进程的进程标识符。</p><p>在 <code>fork()</code> 之后，一个进程使用 <code>exec()</code> ，可以用新程序来取代进程的内存空间。</p><p>这样两个进程就可以互相通信并可以通过各自的方式执行。</p><p>如果子进程运行时没有什么可以做，那么就可以采用 <code>wait()</code> 把自己移出就绪队列来<strong>等待子进程</strong>的终止。</p><p>Copy</p><pre><code>#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

void main(int argc, char *argv[]) &#123;
    pid_t pid;
    pid = fork();

    if (pid &lt; 0) &#123;
        fprintf(stderr, &quot;Fork Failed&quot;);
        exit(-1);
    &#125; else if (pid == 0) &#123;
        execlp(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL);
    &#125; else &#123;
        wait(NULL);
        printf(&quot;Child Complete&quot;);
        exit(0);
    &#125;
&#125;
</code></pre><p>PS: <code>Copy on write</code> : 需要写的时候才发生内存复制。</p><h5 id="windows-中"><a class="anchor" href="#windows-中">#</a> Windows 中</h5><p>使用 <code>Win32 API</code> 中的 <code>CreateProcess()</code> 函数， 执行时，函数将一个特殊程序装入子进程的地址空间。需要至少 10 个参数。</p><pre><code>CreateProcess()` 需要两个参数`STARTUPINFO` 和 `PROCESS_INFORMATION
</code></pre><p><code>STARTUPINFO</code> 指明新进程的许多特性，如窗口大小、标准输入及输出文件句柄</p><p><code>PROCESS_INFORMATION</code> 包括一个句柄以及新生成进程和线程的标识</p><p>调用前，需要使用 <code>ZeroMenory()</code> 为这两个结构清空内存</p><pre><code>Win32 API`相对于`Linux` 的`wait()`是`WaitForSingleObject()
</code></pre><h4 id="进程终止"><a class="anchor" href="#进程终止">#</a> 进程终止</h4><p>当进程执行完调用 <code>exit()</code> 后，进程终止，返回状态值到父进程，所有进程资源被释放。</p><p>父进程通过<strong>标识符</strong>使用适当的系统调用也可以终止子进程。</p><p>对于某些系统当父进程终止的时候，子进程也会被终止，而某些系统父进程终止后，子进程会以 <code>init</code> 进程作为父进程。</p><h3 id="进程间通信"><a class="anchor" href="#进程间通信">#</a> 进程间通信</h3><p>并发执行的进程可以分为<strong>独立进程</strong>和<strong>协作进程</strong></p><p>独立进程： 不能影响其他进程或被其他进程所影响， 不与任何其他进程共享数据</p><p>协作进程： 能影响其他进程或被其他进程所影响， 与任何其他进程共享数据</p><p>提供环境允许进程协作的优点:</p><ul><li>信息共享 Information sharing</li><li>提高运算速度 Computation seed-up： 把特定任务分成子任务并发执行</li><li>模块化 Modularity： 将系统功能分成独立的进程或线程</li><li>方便 Convenience： 单用户也可以同时执行多任务</li></ul><p>协作进程需要一种进程间通信机制（interprocess communication, IPC）来允许进程相互交换数据与信息。</p><p>两种基本通信模式:</p><ul><li>共享内存<ul><li>更快的速度</li></ul></li><li>信息传递<ul><li>更方便</li><li>交换少量数据</li></ul></li></ul><h4 id="共享内存系统"><a class="anchor" href="#共享内存系统">#</a> 共享内存系统</h4><p>生产者进程产生信息以供消费者进程消费，共享内存时解决<strong>生产者 - 消费者</strong>问题方法中的一种。</p><p>有两种缓冲方式：</p><ul><li>无限缓冲（unbounded-buffer）：消费者可能不得不等待新的项， 生产者总是可以产生新项。</li><li>有限缓冲（bounded-buffer）：缓冲大小固定，如果缓冲为空，消费者等待，如果缓冲为满，生产者等待。</li></ul><p>生产者进程：</p><p>Copy</p><pre><code>item nextProduced

while (true) &#123;
	where(((in + 1) % BUFFER_SIZE) == out); // 当缓冲满了的时候必须等待
	buffer[in] = nextProduced;
	in = (in + 1) % BUFFER_SIZE;
&#125;
</code></pre><p>消费者进程:</p><p>Copy</p><pre><code>item nextConsumed
while (true) &#123;
	while (in == out); // 当缓冲为空的时候必须等待
	nextConsumed = buffer[out];
	out = (out + 1) % BUFFER_SIZE;
&#125;
</code></pre><h3 id="操作系统服务-2"><a class="anchor" href="#操作系统服务-2">#</a> 操作系统服务</h3><h4 id="消息传递系统-ipc"><a class="anchor" href="#消息传递系统-ipc">#</a> 消息传递系统 IPC</h4><p>常用于分布式环境中，如 Web</p><p>消息传递提供一种机制允许进程不必通过共享地址空间来实现通讯与同步</p><p>通信需要有通信线路（communication link）</p><p>通讯线路的实现：</p><ul><li>物理：共享内存、硬件总线</li><li>逻辑：逻辑属性 properties</li></ul><p>逻辑实现线路和发送接收操作的方法：</p><ul><li>直接或间接通信</li><li>同步或异步通信</li><li>自动或显式缓冲</li></ul><h5 id="命名"><a class="anchor" href="#命名">#</a> 命名</h5><p>对于直接通信：</p><p>对称寻址：</p><ul><li><code>send(P, message)</code> : 发送信息到进程 P</li><li><code>receive(Q, message)</code> : 接受来自进程 Q 的信息</li></ul><p>属性：</p><ul><li>每对需要通信的进程之间自动建立线路，进程仅需知道相互通信的标识符</li><li>一个线路只与两个进程相关</li><li>每对进程之间只有一个线路</li></ul><p>非对称寻址：</p><ul><li><code>send(P, message)</code> : 发送信息到进程 P</li><li><code>receive(id, message)</code> : 接受来自任何进程的信息，id 设置成与其通信的进程名称</li></ul><p>这两种寻址方式的缺点在于限制了进程定义的模式化，改变进程名字需要检查其他所有进程的定义。</p><p>对于间接通信：</p><p>通过邮箱和端口来发送或接受信息。</p><p>一个进程可能通过许多不同的邮箱与其他进程通信，但两个进程仅在其共享至少一个邮箱时可以相互通信。</p><ul><li><code>send(A, message)</code> ： 发送一个消息到邮箱 A</li><li><code>receive(A, message)</code> : 接受来自邮箱 A 的消息</li></ul><p>对于这种方案，通信线路有如下属性：</p><ul><li>只有在两个进程共享一个邮箱，才能建立通信线路</li><li>一个线路可以与两个或更多的进程相关联</li><li>两个通信进程之间可有多个不同的线路，每个线路对于一个邮箱</li><li>连接可能是单向 <code>unidirectional</code> 或者双向 <code>bi-directional</code></li></ul><p>操作系统需提供的机制：</p><ul><li>创建新邮箱</li><li>通过邮箱发送和接受消息</li><li>删除邮箱</li></ul><p>邮箱的拥有权和接受权可以通过系统调用传递给其他进程。</p><h5 id="同步"><a class="anchor" href="#同步">#</a> 同步</h5><p>消息传递可以时阻塞或非阻塞（同步或异步）</p><ul><li>阻塞 send： 发送进程阻塞， 直到消息被接受进程或邮箱所接受</li><li>非阻塞 send： 发送进程发送消息并再继续操作</li><li>阻塞 receive： 接收者阻塞， 直到有消息可用</li><li>非阻塞 receive： 接收者收到一个有效信息或空信息</li></ul><p>当 <code>send()</code> 和 <code>receive()</code> 都阻塞， 发送者和接收者之间就有一个 <code>集合点（rendezvous）</code></p><h5 id="缓冲"><a class="anchor" href="#缓冲">#</a> 缓冲</h5><ul><li>无缓冲<ul><li>零容量：阻塞</li></ul></li><li>自动缓冲<ul><li>有限容量： 线路满后阻塞</li><li>无限容量： 不阻塞</li></ul></li></ul><h3 id="客户机-服务器系统通信"><a class="anchor" href="#客户机-服务器系统通信">#</a> 客户机 - 服务器系统通信</h3><p>除了共享内存和消息传递，还有三种通信方法： Socket、远程过程调用（RPC）和 Java 的远程方法调用（RMI）</p><h4 id="socket"><a class="anchor" href="#socket">#</a> Socket</h4><p>Socket（套接字）可定义为通信的端点。一对通过网络通信的进程需要使用一对 Socket（即每个进程各有一个）。</p><p>Socket 由 IP 地址和一个端口号连接组成</p><p>服务器通过 <strong>监听制定端口</strong> 来等待进来的客户请求， 一旦受到请求， 就接受来自客户 Socket 的连接， 从而完成连接。</p><p>Java 提供了三种不同类型的 Socket</p><ul><li>面向连接（TCP）Socket： Socket 类</li><li>无连接（UDP）Socket： DatagramSocket 类</li><li>多点传送 Socket： DatagramSocket 的子类（允许数据发送到多个接收者）</li></ul><p>使用 Socket 通信，虽然常用和高效， 但是属于较为低级的分布式进程通信。原因之一在于 Socket 只允许在通信进程之间交换 ** 无结构的字节流 **</p><h4 id="远程过程调用"><a class="anchor" href="#远程过程调用">#</a> 远程过程调用</h4><p>Remote Procedure Calls, RPC</p><p>RPC 抽象层远程调用机制，用于通过网络连接系统</p><p>存根 Stubs： 用于服务器上的实际程序的客户端代理</p><p>客户端使用存根定位服务器，并提供参数</p><p>服务器接收信息，解析后运行指定的程序</p><h2 id="第-4-章-线程"><a class="anchor" href="#第-4-章-线程">#</a> 第 4 章 线程</h2><h3 id="概述"><a class="anchor" href="#概述">#</a> 概述</h3><p>线程是 CPU 使用的基本单元。它与属于同一进程的其他线程共享代码段、数据段和其他操作系统资源。</p><p>组成：</p><ul><li>线程 ID</li><li>程序计数器</li><li>寄存器集合</li><li>栈</li></ul><h4 id="优点"><a class="anchor" href="#优点">#</a> 优点</h4><ul><li>响应度高：即使部分阻塞，程序也能继续执行，从而增加了对用户的相应速度</li><li>资源共享：线程默认共享他们所属的进程的内存和资源</li><li>经济：进程创建所需要的内存和资源的分配比较昂贵，创建和切换线程比较经济</li><li>多处理器体系结构的利用：多线程可以并行在不同的 CPU 上</li></ul><h3 id="多线程模型"><a class="anchor" href="#多线程模型">#</a> 多线程模型</h3><p>有两种不同方法提供线程支持：</p><ul><li>用户层的用户线程</li><li>内核层的内核线程（由操作系统直接支持和管理）</li></ul><h4 id="多对一模型"><a class="anchor" href="#多对一模型">#</a> 多对一模型</h4><p>将许多用户级线程映射到一个内核线程。</p><p>线程管理是由线程库在用户空间进行的，因而<strong>效率比较高</strong></p><h4 id="一对一模型"><a class="anchor" href="#一对一模型">#</a> 一对一模型</h4><p>将每个用户线程映射到一个内核线程</p><p>开销比较大</p><h4 id="多对多模型"><a class="anchor" href="#多对多模型">#</a> 多对多模型</h4><p>开发人员可以创建任意多的用户线程，并且相应内核线程能在多处理器系统上并发执行。</p><p>并且在一个线程执行阻塞系统调用的时候，内核能调度另一个线程来执行。</p><h4 id="二级模型"><a class="anchor" href="#二级模型">#</a> 二级模型</h4><p>类似于多对多模型，二级模型还允许用户线程绑定在一个内核线程里面</p><h3 id="线程库"><a class="anchor" href="#线程库">#</a> 线程库</h3><p>为程序员提供创建和管理线程的 API</p><p>两种方法:</p><ul><li>在用户空间提供一个没有内核支持的库</li><li>执行一个由操作系统直接支持额内核级的库</li></ul><h3 id="多线程问题"><a class="anchor" href="#多线程问题">#</a> 多线程问题</h3><h4 id="系统调用-fork和-exec"><a class="anchor" href="#系统调用-fork和-exec">#</a> 系统调用 fork () 和 exec ()：</h4><p>fork:</p><ul><li>可以复制所有线程</li><li>仅仅复制调用 fork 系统调用的线程</li></ul><p>exec:</p><p>如果一个线程调用 exec ()，那么整个进程都会被替换</p><p>如果 fork 后立即调用 exec，那么就没有必要复制所有线程</p><h4 id="线程取消-thread-cancellation"><a class="anchor" href="#线程取消-thread-cancellation">#</a> 线程取消 Thread Cancellation</h4><p>在线程执行完成后中止</p><p>取消方法：</p><ul><li>异步取消 (asynchronous cancellation)：立即终止目标线程</li><li>延迟取消 (deferred cancellation)：允许目标线程周期性地检查是否应该取消该线程，这些检查点称为取消点 (cancellation point)</li></ul><h4 id="信号处理-signal-handling"><a class="anchor" href="#信号处理-signal-handling">#</a> 信号处理 Signal Handling</h4><p>信号处理程序用于通知进程某个特性事件发生了</p><p>可以为同步或异步接收</p><p>模式：</p><ul><li>信号是由特定事件产生的</li><li>生成的信号传递到进程</li><li>一旦发送，信号必须加以处理</li></ul><p>信号的处理：</p><ul><li>默认的信号处理程序 (default signal handler)</li><li>用户定义的信号处理程序</li></ul><p>信号发送的选择（依赖于信号的类型）：</p><ul><li>将信号传递到信号<strong>所应用的线程</strong></li><li>将信号传递给进程中的<strong>每个线程</strong></li><li>将信号传递给进程中的某些<strong>固定线程</strong></li><li>指定一个<strong>特定的线程</strong>来接收进程的所有信号</li></ul><h4 id="线程池"><a class="anchor" href="#线程池">#</a> 线程池</h4><p>优点：</p><ul><li>通常比创建新的线程要快</li><li>限制了任何时候的可用线程数</li></ul><h4 id="线程的特定数据-thread-specific-data"><a class="anchor" href="#线程的特定数据-thread-specific-data">#</a> 线程的特定数据 Thread Specific Data</h4><p>允许每个线程有自己的一定的数据副本</p><p>当使用线程池的时候有用（不是自己创建进程的时候）</p><h4 id="调度程序激活"><a class="anchor" href="#调度程序激活">#</a> 调度程序激活</h4><p>Scheduler Activations</p><p>多对多和二级模型都需要内核与线程库之间的通信（允许动态调整内核线程的数量以保证最好的性能）</p><p>内核通过 upcall 与线程库通信，允许应用程序维护正确的内核线程数</p><p>内核提供一组虚拟处理器 (LWP) 给应用程序，应用程序可调度用户线程到一个可用的 LWP 中。</p><p>upcall 处理句柄必须在虚拟处理器上运行。</p><h2 id="第-5-章-cpu-调度"><a class="anchor" href="#第-5-章-cpu-调度">#</a> 第 5 章 CPU 调度</h2><h3 id="基本概念"><a class="anchor" href="#基本概念">#</a> 基本概念</h3><p>当一个程序必须等待时，操作系统会从该进程拿走 CPU 的使用权，而将 CPU 交给其他进程</p><h4 id="cpu-io-区间"><a class="anchor" href="#cpu-io-区间">#</a> CPU-I/O 区间</h4><p>进程执行由 CPU 执行和 I/O 等待周期组成，进程在这两个状态之间切换。</p><p>CPU 约束程序可能有少量的长 CPU 区间</p><p>I/O 约束程序通常具有很多短 CPU 区间</p><h4 id="cpu-调度程序"><a class="anchor" href="#cpu-调度程序">#</a> CPU 调度程序</h4><p>当 CPU 空闲，操作系统从就绪队列选择一个进程执行，从内存中选择并为之分配 CPU</p><p>就绪队列的实现可以为：FIFO 队列， 优先队列，树或简单的无序链表，其内容通常为进程控制块 (PCB)</p><h4 id="抢占调度"><a class="anchor" href="#抢占调度">#</a> 抢占调度</h4><p>CPU 调度决策的发生：</p><ul><li>运行状态切换到等待状态</li><li>运行状态切换到就绪状态</li><li>等待状态切换到就绪状态</li><li>进程终止</li></ul><p>第一种和第四种没有选择只有调度， 称为非抢占的 (non-preemptive) 或协作的 (cooperative)</p><p>否则调度方案就是抢占的 (preemptive)</p><p>抢占调度需要特别的硬件（如计时器）的支持，因此有的设备只能使用协作调度</p><p>注意：抢占调度对访问共享数据有代价，对操作系统内核设计也有影响。</p><h4 id="分派程序-dispatcher"><a class="anchor" href="#分派程序-dispatcher">#</a> 分派程序 Dispatcher</h4><p>用于将 CPU 的控制交给由短期调度程序选择的进程，功能:</p><ul><li>切换上下文</li><li>切换到用户模式</li><li>跳转到用户程序的合适位置，以重新启动程序</li></ul><p>分派程序停止一个进程而启动另一个所要花的时间称为分派延迟 (dispatch latency)</p><h3 id="调度准则-scheduling-criteria"><a class="anchor" href="#调度准则-scheduling-criteria">#</a> 调度准则 Scheduling Criteria</h3><ul><li>CPU 使用率 CPU utilization： 使得 CPU 尽可能忙</li><li>吞吐量 Throughput： 指一个时间单元内所完成进程的数量</li><li>周转时间 Turnaround time: 从进程提交到进程完成的时间段。包括等待进入内存，在就绪队列中等待， 在 CPU 上执行和 I/O 执行</li><li>等待时间 Waiting time ：在就绪队列中等待所花的时间之和</li><li>响应时间 Response time： 从提交请求到产生第一响应的时间</li></ul><p>需要使得 CPU 使用率，吞吐量最大化，使周转时间，等待时间，响应时间最小化。</p><h3 id="调度算法"><a class="anchor" href="#调度算法">#</a> 调度算法</h3><h4 id="先到先服务调度"><a class="anchor" href="#先到先服务调度">#</a> 先到先服务调度</h4><p>first-come, first-served(<strong>FCFS</strong>) Scheduling algorithm</p><p>先请求 CPU 的进程先分配到 CPU</p><p>使用 FIFO 队列实现</p><p>通常平均等待时间比较长。</p><p><strong>护航效果 (convoy effect)</strong>: 所有其他进程都在等待一个大进程释放 CPU，导致 CPU 和设备的利用率变得更低</p><p>FCFS 调度算法是<strong>非抢占</strong>的。</p><h4 id="最短作业优先调度"><a class="anchor" href="#最短作业优先调度">#</a> 最短作业优先调度</h4><p>shortest-job-first (<strong>SJF</strong>) scheduling algorithm</p><p>优先赋给具有最短 CPU 区间的进程</p><p>SJF 调度算法可证明为<strong>最佳的</strong></p><p>难点在于如何知道下一个 CPU 区间的长度，因此一般用于长期调度，将用户提交作业时所指定的进程时间极限作为长度。</p><p>预测算法：</p><p>T(n+1)=αtn+(1−α)TnT(n+1)=αtn+(1−α)Tn</p><p>当 α=0α=0 最近的历史没有统计</p><p>当 α=1α=1 只是根据上一次的运行时间</p><p>对于短期调度，通常去根据以前的 CPU 区间长度来预测下一个。预测值为之前的指数平均</p><p>SJF 调度算法可以为抢占或者时非抢占的。</p><p>抢占式的 SJF 可抢占当前运行的进程，有时称为<strong>最短剩余时间优先调度</strong> (shortest-remaining-time-first scheduling, SRTF)</p><p>非抢占式的允许当前运行的进程先完成其 CPU 区间。</p><h4 id="优先级调度"><a class="anchor" href="#优先级调度">#</a> 优先级调度</h4><p>SJF 算法可以作为通用优先级调度算法 (priority scheduling algorithm) 的一个特例，优先级为下一个 CPU 区间的倒数</p><p>每个进程都有一个优先级与其相关联，具有最高优先级的进程会分配到 CPU，具有相同优先级的按 FCFS 顺序调度。</p><p>优先级可以通过内部或者外部定义，内部通常使用一些测量数据，如：时间极限，内存要求，打开文件的数量和平均 I/O 区间和平均 CPU 区间。</p><p>优先级调度可以式抢占或者式非抢占的。</p><p>主要问题：无穷阻塞 (indefinite blocking) 或饥饿 (starvation)</p><p>可以运行但缺乏 CPU 的进程被认为是阻塞的，他在等待 CPU，调度算法会使某个低优先级进程无穷等待 CPU</p><p>解决方案：老化 (aging)， 逐渐增加在系统中等待很长时间的进程的优先级。</p><h4 id="轮转法调度"><a class="anchor" href="#轮转法调度">#</a> 轮转法调度</h4><p>round-robin, RR</p><p>专门为分时系统设计，在 FCFS 上增加了抢占以切换进程。改进了响应时间。</p><p>定义一个较小的时间单元，称为时间片 (time quantum. or time slice)，通常为 10~100ms，将就绪队列作为循环队列，为每个进程分配不超过一个时间片的 CPU</p><p>RR 策略的平均等待时间通常较长，性能很大程序依赖于时间片的大小，如果时间片很小，那么 RR 算法就称为<strong>处理器共享</strong></p><p>性能：</p><p>当时间段比较长的时候：退化为 FIFO</p><p>当时间段比较短的时候：时间段必须大于上下文切换的时间，否则开销会很大</p><h4 id="多级队列调度"><a class="anchor" href="#多级队列调度">#</a> 多级队列调度</h4><p>multilevel queue scheduling</p><p>将就绪队列分成多个独立队列。根据进程的属性（内存大小，进程优先级， 进程类型）</p><p>每个队列有自己的调度算法，如</p><ul><li>前台队列：RR 算法</li><li>后台队列：FCFS 算法</li></ul><p>队列之间也必须有调度，通常采用固定优先级抢占队列，比如前台队列对于后台队列有绝对的优先级，不过固定的优先级可能会引起饥饿</p><p>队列之间也可以划分时间片，每个队列有一定的 CPU 时间（如，80% 的时间给前台队列，20% 给后台）</p><h4 id="多级反馈队列调度"><a class="anchor" href="#多级反馈队列调度">#</a> 多级反馈队列调度</h4><p>multilevel feedback queue scheduling</p><p>比多级队列调度更加灵活，但是开销也更大</p><p>允许进程在队列之间移动，主要思想是根据不同的 CPU 区间的特点以区分进程。如果进程使用过多 CPU 时间，那么它就会被转移到更低优先级的队列，如果低优先级队列中等待时间过长，那么也会被转移到更高优先级队列。这种老化防止了饥饿的发生。</p><p>通常，可以由以下参数来定义</p><ul><li>队列数量</li><li>每个队列的调度算法</li><li>用以确定何时升级到更高优先级队列的方法</li><li>用以确定何时降级到更低优先级队列的方法</li><li>用以确定进程在需要服务时应进入哪个队列的方法</li></ul><p>多级反馈队列调度程序为最通用的 CPU 调度算法，也是最复杂的。</p><p>如：</p><p>首先进程进入第一级 FCFS 队列，如果 8ms 内不能完成，就移到第二级 FCFS 队列，如果 16ms 内不能完成，就进入三级 FCFS 队列</p><p>高级队列的优先级最高，仅当高级队列为空，才调度较低优先级的队列。如果低优先级的进程被抢占，则放入原队列的末尾。</p><p>如果进程请求 I/O，让出了 CPU 则 I/O 完成后，放入比原来队列高一级的队列中</p><h3 id="多处理器调度"><a class="anchor" href="#多处理器调度">#</a> 多处理器调度</h3><p>多个 CPU 可实现负载分配 (load sharing)，调度问题也更加地复杂</p><p>即使对于同构多处理器，也有一些调度限制，比如一个 I/O 设备与一个处理器通过私有总线相连，那么必须把使用改设备的进程调度到这个 CPU 上去运行。</p><p>实时调度：</p><ul><li>Hard real-time systems：保证在一定时间内完成重要的任务</li><li>Soft real-time systems：重要进程的优先级比其他的高</li></ul><h4 id="多处理器调度的方法"><a class="anchor" href="#多处理器调度的方法">#</a> 多处理器调度的方法</h4><ul><li>非对称多处理 (asymmetric multiprocessing)<ul><li>一个处理器（主服务器）处理所有的调度决定、I/O 处理以及其他系统活动</li><li>其他处理器只执行用户代码</li><li>更加简单，减轻了对数据共享的需要</li></ul></li><li>对称多处理 (symmetric multiprocessing, SMP)<ul><li>每个处理器自我调度</li><li>调度通过每个处理器检查共同就绪队列并选择一个进程来执行</li><li>必须保证两个处理器不能选择同一个进程，并且进程不会从对联中丢失</li></ul></li></ul><h4 id="处理器亲和性"><a class="anchor" href="#处理器亲和性">#</a> 处理器亲和性</h4><p>当一个特定的进程在处理器上运行的时候，进程最近访问的数据进入处理器缓存，缓存的失效和重新构建代价时很高的。</p><p>处理器亲和性： 避免将进程从一个处理器移到另一个处理器，使得一个进程在同一个处理器上运行</p><ul><li>软亲和性 soft affinity ： 进程可能在处理器之间移动</li><li>硬亲和性 hard affinity：进程被指定不允许移到其他处理器</li></ul><h4 id="负载平衡"><a class="anchor" href="#负载平衡">#</a> 负载平衡</h4><p>设法将工作负载平均地分配到 SMP 系统的所有处理器上。</p><p>只是对于那些拥有子集私有的可执行进程的处理器是必要的，对于有共同队列的系统是不需要的。</p><p>通常有两种方法：</p><ul><li>push migration<ul><li>一个特定的任务周期性地检查每个处理器上的负载，发现不平衡就将进程从超载 CPU 移动到空闲 CPU</li></ul></li><li>pull migration<ul><li>空闲处理器从一个超载处理器 pull 一个等待任务</li></ul></li></ul><p>通常这两种技术并行地实现</p><p>负载平衡通常会抵消处理器亲和性的优点。</p><h4 id="对称多线程"><a class="anchor" href="#对称多线程">#</a> 对称多线程</h4><p>SMT</p><p>SMP 是基于多个物理处理器，SMT 基于多个逻辑处理器，也称为超线程技术 (Hyperthreading)</p><p>SMT 的思想是在同一个物理处理器生成多个逻辑处理器，向操作系统呈现一个多逻辑处理器的视图。每个逻辑处理器都有自己的架构状态</p><p>SMT 是硬件提供的。</p><h3 id="线程调度"><a class="anchor" href="#线程调度">#</a> 线程调度</h3><p>线程：</p><ul><li>用户线程</li><li>内核线程</li></ul><h4 id="竞争范围"><a class="anchor" href="#竞争范围">#</a> 竞争范围</h4><p>进程竞争范围（process-contention scope, PCS）（Local Scheduling）：线程库调度用户级线程到一个有效的 LWP 上运行（根据优先级）</p><p>系统竞争范围（system-contention scope, SCS）（Global Scheduling）：调度内核线程到 CPU</p><h3 id="算法评估"><a class="anchor" href="#算法评估">#</a> 算法评估</h3><p>定义准则：</p><ul><li>最大化 CPU 使用率，同时要求最大相应时间为 1s</li><li>最大化吞吐量（平均周转时间与总地执行时间成正比）</li></ul><h4 id="确定类型"><a class="anchor" href="#确定类型">#</a> 确定类型</h4><p>评估方法:</p><ul><li>分析评估法 (analytic evaluation)：使用给定的算法和系统负荷，产生一个公式或数字来评估</li><li>确定模型法 (deterministic modeling)：采用特殊预先确定的符合，计算在给定负荷下算法的性能</li></ul><h4 id="排队模型"><a class="anchor" href="#排队模型">#</a> 排队模型</h4><p>排队网络分析 (queueing-network analysis)：知道到达率和服务率，计算使用率，平均队列长度，平均等待时间等</p><p>Little 公式： n=λ×Wn=λ×W</p><h2 id="第-6-章-进程同步"><a class="anchor" href="#第-6-章-进程同步">#</a> 第 6 章 进程同步</h2><p>进程或线程异步执行并且共享数据，那么就有可能不能正确运行</p><p>竞争条件 race condition： 多个进程并发访问和操作同一数据并且执行结果与访问发生的特定顺序有关</p><p>为了避免竞争条件，需要确保一段时间内只有一个进程能操作变量，要求进行一定形式的进程同步</p><p>因此需要进程同步 (process synchronization) 和协调 (coordination)</p><h3 id="临界区问题"><a class="anchor" href="#临界区问题">#</a> 临界区问题</h3><p>临界区 (critical section)： 每个进程中的一个代码段，在该区内进程可能改变共同变量等操作。</p><p>每个进程必须请求允许进程临界区，请求进入的代码称为进入区 (entry section), 临界区后可有退出区 (exit section), 其他代码为剩余区 (remainder section)</p><p>临界区问题的三个要求：</p><ul><li>互斥 mutual exclusion: 当一个进程进入临界区，那么其他进程不能再临界区内运行。(无空等待)</li><li>前进 progress: 如果没有进程再其临界区内执行且有进程需要进入临界区，那么只有哪些不在剩余区内执行的进程可以参加选择，确定谁能进入临界区，而且这种选择不能无限推迟（有空让进）</li><li>有限等待 bounded waiting: 从一个进程做出进入临界区的请求，直到道该请求允许为止，其他进程允许进入临界区的次数有限。</li></ul><p>处理临界问题</p><p>抢占内核 preemptive kernel， 需要设计以确保内核数据结构不会导致竞争条件。更适合实时编程，允许实时进程抢占内核默认运行的其他类型，响应更快。</p><p>非抢占内核 nonpreemptive kernel， 从内核数据结构上就不会导致竞争条件</p><p>让权等待：当进程不能进入自己的临界区的时候，释放处理器，以免进程进入盲等</p><h3 id="一些解法"><a class="anchor" href="#一些解法">#</a> 一些解法</h3><p>双标志、先检查：可能两个都进入临界区</p><p>双标志、后检查：可能两个都不能进入临界区</p><h3 id="peterson-算法"><a class="anchor" href="#peterson-算法">#</a> Peterson 算法</h3><p>Copy</p><pre><code>do &#123;
    flag[i] = true;
    turn = j;
    while (flag[j] &amp;&amp; turn == j);
    临界区
    flag[i] = false;
    剩余区
&#125; while (true);
</code></pre><p>适用于两个进程再临界区与剩余区间交替执行</p><p>此算法：</p><ul><li>互斥成立</li><li>前进要求满足</li><li>有限等待要求满足</li></ul><h3 id="硬件同步"><a class="anchor" href="#硬件同步">#</a> 硬件同步</h3><p>很多系统提供临界区的硬件支持</p><p>单处理器：关中断，确保当前指令序列执行不被中断，常为非抢占内核使用</p><p>多处理器：提供特殊硬件指令允许原子地检查和修改字的内容或交换两个字的内容</p><p>Copy</p><pre><code>do &#123;
    请求锁
        临界区
    释放锁
        剩余区
&#125; while(true);
</code></pre><p>Copy</p><pre><code>boolean TestAndSet(boolean *target) &#123;
    boolean rv = *target;
    *target = true;
    return rv;
&#125;

do &#123;
    while (TestAndSet(&amp;lock));
    // do something
    lock = false;
&#125; while (true);

void Swap(boolean *a, boolean *b) &#123;
    boolean temp = *a;
    *a = *b;
    *b = temp;
&#125;

do &#123;
    key = true;
    while (key == true) Swap(&amp;lock, &amp;key);
    // do something
    lock = false;
&#125; while (true);
</code></pre><p>以上为两种实现方法</p><p>优点：</p><ul><li>适用于任意数目的进程，在单处理器和多处理器</li><li>简单</li><li>可以支持进程内存在多个临界区，只需为每个临界区设立一个布尔变量</li></ul><p>缺点：</p><ul><li>等待需要耗费 CPU 时间，不能实现让权等待</li><li>可能饥饿，优先级问题</li><li>可能死锁， 优先级问题，如果有一个更高优先级的进程在临界区执行时中断并且需要这个进程的资源，就会造成死锁</li></ul><h3 id="信号量"><a class="anchor" href="#信号量">#</a> 信号量</h3><p>semaphore</p><p>一个同步工具</p><p>信号量 S 是个整型变量，除初始化外，只能通过两个标准原子操作 <code>wait()</code> 和 <code>signal()</code> 访问，也称为 P 和 V</p><p>Copy</p><pre><code>wait(S) &#123;
    while(S &lt;= 0);
    S--;
&#125;
signal(S) &#123;
    S++;
&#125;
</code></pre><p>使用方法：</p><p>Copy</p><pre><code>mutex = 1;
do &#123;
    wait(mutex);
    // do something
    signal(mutex)
&#125; while (true);
</code></pre><p>缺点：忙等待。通过循环浪费了 CPU，称为自旋锁 (spinlock)</p><p>改进： 变成阻塞自己，将进程放入与信号量相关的等待队列， 并切换进程状态为等待状态。</p><p>Copy</p><pre><code>typedef struct &#123;
	int value;
    struct process *list;
&#125; semaphore;
</code></pre><p>当一个进程必须等待信号量，那么就加入进程链表， <code>signal()</code> 会从等待链表中取一个进程以唤醒。</p><p>Copy</p><pre><code>wait (semaphore *S) &#123;
    S-&gt;value--;
    if (S-&gt;value &lt; 0) &#123;
        add this process to S-&gt;list;
        block(); // 挂起调用它的进程
    &#125;
&#125;

signal(semaphore *S) &#123;
    S-&gt;value++;
    if (S-&gt;value &lt;= 0) &#123;
        remove a process P from S-&gt;list;
        wakeup(P); // 重新启动阻塞进程P的执行
    &#125;
&#125;
</code></pre><p><code>value</code> 就是等待的进程数。</p><p>大于等于 0 的时候就是可用资源数。</p><p>小于 0 就是等待进入临界区的进程个数</p><p>如果定义信号量 flag 为 0，可以先 <code>signal</code> 再 <code>wait</code> ， 确认操作完成后再继续执行。</p><p>对于单处理器，可以执行 <code>wait</code> 和 <code>signal</code> 操作时简单地禁止中断，对于多处理器，必须禁止每个处理器的中断，或者提供其他加锁技术（如自旋锁 Spinlock，特点就是忙等待），使得这两个命令可以原子地执行。</p><p>并没有完全取消忙等，而是取消了应用程序进入临界区的忙等。</p><p><code>wait</code> 和 <code>signal</code> 必须成对出现:</p><ul><li>互斥操作时，处于同一进程</li><li>同步操作时，不在同一进程</li></ul><p>如果两个 <code>wait</code> 相邻，那么他们顺序很重要（同步操作应该在互斥操作之前）， <code>signal</code> 则不重要。</p><p>优点：简单，表达能力强，能解决任何同步互斥问题</p><p>缺点：不够安全，当使用不当会出现死锁，实现复杂</p><h4 id="死锁和饥饿"><a class="anchor" href="#死锁和饥饿">#</a> 死锁和饥饿</h4><p>当信号量使用顺序不对，就有可能造成死锁。</p><p>当两个或多个进程无限等待一个事件，而该事件只能由这些等待进程之一来产生，那么这些进程就会称为死锁 (deadlocked)</p><p>当进程再信号量内无限期等待，就会导致无限期阻塞 (indefinite blocking) 或饥饿 (starvation)</p><h3 id="经典同步问题"><a class="anchor" href="#经典同步问题">#</a> 经典同步问题</h3><h4 id="有限缓冲问题"><a class="anchor" href="#有限缓冲问题">#</a> 有限缓冲问题</h4><ul><li><code>mutex</code> 提供对缓冲池访问的互斥要求，初始化为 1</li><li><code>empty</code> 表示空缓冲项，初始化为 n</li><li><code>full</code> 表示满缓冲项，初始化为 0</li></ul><p>Copy</p><pre><code>// 生产者
do &#123;
    // produce an item in nextp
    wait(empty);
    wait(mutex);
    // add nextp to buffer
    signal(mutex);
    signal(full);
&#125; while (true);

// 消费者
do &#123;
    wait(full);
    wait(mutex);
    // r3emove an item from buffer to nextc
    signal(mutex);
    signal(empty);
    // consume the item in nextc
&#125; while (true);
</code></pre><h4 id="读者-写者问题"><a class="anchor" href="#读者-写者问题">#</a> 读者 - 写者问题</h4><ul><li>第一读者 - 写者问题（<strong>读者优先</strong>）： 要求没有读者需要保持等待除非已有一个写者已获得允许以使用共享数据库，即没有读者会因为有一个写者在等待而会等待其他读者的完成. (即使有一个写者在等待，读者也会无视读者的锁而进行并发地读取，可能导致写者饥饿)</li><li>第二读者 - 写者问题（<strong>写者优先</strong>）： 一旦写者就绪，那么写着就会尽可能快地执行写操作，即如果是个写者等待访问对象，那么不会有新读者开始读操作（一旦有写者等待，读者就会不会开始，可能导致读者饥饿</li></ul><p>第一读者写者问题解决</p><p>Copy</p><pre><code>semaphore mutex = 1, wrt = 1;
// mutex 修改readcount的互斥
// wrt 写者的互斥
int readcount = 0;

// 写者进程结构
do &#123;
    wait(wrt);
    ...
    // writing is performed
    ...
    signal(wrt);
&#125; while (true);

// 读者进程结构
do &#123;
    wait(mutex);
    readcount++;
    if (readcount == 1) &#123; // 当前没有读者，需要等待/获取写者互斥
        wait(wrt);
    &#125;
    signal(mutex);
    ...
    // reading is performed
    ...
    wait(mutex);
    readcount--;
    if (readcount == 0) &#123; // 所有读者退出，释放写者互斥
        signal(wrt);
    &#125;
    signal(mutex);
&#125; while (true);
</code></pre><p>第二读者写者问题</p><p>Copy</p><pre><code>semaphore rmutex = 1, wmutex = 1, readTry = 1, resource = 1;
// rmutex 修改readcount的互斥
// wmutex 修改writecount的互斥
// readTry 锁住进入读者队列
// resouce 写者修改资源的互斥
int readcount = 0, writecount = 0;

// 写者进程结构
do &#123;
    wait(wmutex);
    writecount++;
    if (writecount == 1) &#123; // 当前没有写者，需要先锁住读者队列
        wait(readTry);
    &#125;
    signal(wmutex);
    wait(resouce); // 需要获得资源的独占访问
    ...
    // writing is performed
    ...
    signal(resouce);
    wait(wmutex);
    writecount--;
    if (writecount == 0) &#123; // 所有写者退出，释放读者队列的锁
        signal(readTry);
    &#125;
    signal(wmutex);

&#125; while (true);

// 读者进程结构
do &#123;
    wait(readTry); // 获取进入读者队列的锁
    wait(rmutex);
    readcount++;
    if (readcount == 1) &#123; // 当前没有读者，需要等待/获取资源独占锁
        wait(resource);
    &#125;
    signal(rmutex);
    signal(readTry);
    ...
    // reading is performed
    ...
    wait(rmutex);
    readcount--;
    if (readcount == 0) &#123; // 所有读者退出，释放写者互斥
        signal(resource);
    &#125;
    signal(rmutex);
&#125; while (true);
</code></pre><p>某些系统提供读写锁</p><p>多个进程可允许并发获取读模式的读写锁，只有一个进程可以为写操作获取读写锁</p><p>需要读写锁的情况：</p><ul><li>当可以区分哪些进程需要读共享数据哪些进程只需写共享数据、</li><li>当读者进程数比写者进程多时。</li></ul><h4 id="哲学家进餐问题"><a class="anchor" href="#哲学家进餐问题">#</a> 哲学家进餐问题</h4><p>典型的同步问题，并发控制的问题。</p><p>需要在多个进程之间分配多个资源且不会出现死锁和饥饿</p><p>一个简单的解决方法就是每一个资源使用一个信号量表示</p><p>Copy</p><pre><code>emaphore chopstick[5]; // 初始化为1
do &#123;
    wait(chopstick[i]);
    wait(chopstick[(i + 1) % 5]);
    // eat
    signal(chopstick[i]);
    signal(chopstick[(i + 1) % 5]);
    // think
&#125; while (true);
</code></pre><p>但是这个方法会导致死锁</p><p>我们需要保证：</p><ul><li>最多允许 4 个哲学家同时坐在桌子上</li><li>只有两只筷子都可用的时候才允许一个哲学家拿起他们（必须在临界区内拿起）</li><li>使用非对称解决方法<ul><li>奇数哲学家先拿起左边的筷子，然后拿起右边的筷子，而偶数哲学家则相反</li></ul></li></ul><p>但是<strong>还是不能解决</strong>饥饿的问题</p><h3 id="管程-monitors"><a class="anchor" href="#管程-monitors">#</a> 管程 Monitors</h3><p>使用信号量还是可能导致错误，或者调用顺序一旦不被遵守，那么就会出现死锁，因此需要管程，monitor</p><h4 id="使用"><a class="anchor" href="#使用">#</a> 使用</h4><p>管程类型提供了一组由程序员定义的、在管程内互斥的操作。</p><p>管程类型的表示不能直接为各个进程所使用，在管程内定义的子程序只能访问位于管程内那些局部声明和变量形式参数，局部变量只能被局部子程序访问。</p><p>管程结构确保一次<strong>只有一个进程</strong> 能在管程内活动， 但是还需一些额外的同步机制，由条件 (condition) 结构来提供。</p><p>Copy</p><pre><code>condition x, y;
x.wait(); // 调用操作的进程会被挂起
x.signal(); // 重新启动一个悬挂的进程，如果没有，那么就没有任何操作（与信号量不同）
</code></pre><p>管程的语法</p><p>Copy</p><pre><code>monitor monitor name &#123;
    // shared variable declarations
    procedure P1 (...) &#123;
        ...
    &#125;
    procedure P2 (...) &#123;
        ...
    &#125;
    ...
    procedure Pn (...) &#123;
        ...
    &#125;
    initalization code (...) &#123;
        ...
    &#125;
&#125;
</code></pre><p>当操作 <code>x.signal()</code> 被进程 P 调用时， Q 被唤醒， 进程 Q 等待直到 P 离开管程，或者等待另一个条件，然后再执行。</p><p>在并行 Pascal 中，当进程 P 执行操作 <code>signal()</code> 时，它会立即离开管程，因此进程 Q 会立刻重新执行。</p><h4 id="哲学家进餐问题的管程解决方案"><a class="anchor" href="#哲学家进餐问题的管程解决方案">#</a> 哲学家进餐问题的管程解决方案</h4><p>需要区分哲学家三种状态，引入数据结构</p><pre><code>enum &#123;THINKING, HUNGRY, EATING&#125; state[5];
</code></pre><p>哲学家只有再其两个邻居不在进餐的时候才能将 <code>state[i]</code> 设置为 <code>eating</code></p><p>还需要声明 <code>condition self[5];</code></p><p>其中哲学家 <code>i</code> 在饥饿且又不能拿到需要筷子时可以延迟自己。</p><p>Copy</p><pre><code>monitor db &#123;
    enum &#123;THINKING, HUNGRY, EATING&#125; state[5];
    condition self[5];

    void pickup(int i) &#123;
        state[i] = HUNGRY;
        test(i);
        if (state[i] != EATING) &#123;
            self[i].wait();
        &#125;
    &#125;

    void putdown(int i) &#123;
		state[i] = THINGKING;
    	test((i + 4) % 5);
    	test((i + 1) % 5)；
    &#125;

    void test(int i) &#123;
        if ((state[(i + 4) % 5] != EATING) &amp;&amp;
           (state[i] == HUNGRY) &amp;&amp;
            (state[(i + 1) % 5] != EATING)) &#123;
            state[i] = EATING;
            self[i].signal();
        &#125;
    &#125;

    initialization_code() &#123;
        for (int i = 0; i &lt; 5; i++) &#123;
            state[i] = THINKING;
        &#125;
    &#125;
&#125;

// 当哲学家i需要进餐
dp.pickup(i);
eat();
dp.putdown(i);
</code></pre><p>这样就可以保证相邻两个哲学家不会同时进餐，并且在哲学家进餐完毕会<strong>唤醒</strong>左右两个哲学家（如果他们正在等待并且已经可以开始吃），这样就<strong>不会出现死锁</strong>，但是还是有<strong>可能饿死</strong>。</p><h4 id="基于信号量的管程实现"><a class="anchor" href="#基于信号量的管程实现">#</a> 基于信号量的管程实现</h4><p>对于每个管程，都有一个信号量 <code>mutex = 1</code> ， 进程在进入管程之前必须执行 <code>wait(mutex)</code> ， 离开管程之和必须执行 <code>signal(mutex)</code></p><p>因为信号进程必须等待，直到重新启动的进程离开或等待，因此引入了信号量 <code>next = 0</code> 以供信号进程挂起自己，然后提供一个整数变量 <code>next_count</code> 对挂起的进程数量进行计数</p><p>Copy</p><pre><code>wait(mutex); // 保证这个管程只有一个在运行
...
if (next_count &gt; 0) &#123;
	signal(next); // 唤醒下一个
&#125; else &#123;
    signal(mutex);
&#125;
</code></pre><p>实现条件变量（引入信号量 <code>x_sem</code> 和整数变量 <code>x_count</code> ）：</p><p>条件变量的两个操作：</p><ul><li><code>x.wait()</code> ： 调用操作的进程被挂起，调用管程的其他程序（有的话）</li><li><code>x.signal()</code> ：恢复调用 <code>x.wait()</code> 的进程</li></ul><p>Copy</p><pre><code>// x.wait()
x_count++;
if (next_count &gt; 0) &#123;
    signal(next);
&#125; else &#123;
    signal(mutex);
&#125;
wait(x_sem);
x_count--;
... // 进行操作
// signal(next); ???

// x.signal()
if (x_count &gt; 0) &#123;
    next_count++;
    signal(x_sem);
    wait(next);
    next_count--;
&#125;
</code></pre><h4 id="管程内的进程重启"><a class="anchor" href="#管程内的进程重启">#</a> 管程内的进程重启</h4><p>简单的解决方案时使用 FCFS 顺序，但是很多情况下可以使用<strong>条件等待</strong>构造 <code>x.wait(c)</code><br>c 为整数，称为<strong>优先级</strong>， 会与悬挂进程的名称一起存储，当执行 <code>x.signal()</code> 最小优先级的程序会被启动。</p><p>管程不能正常运行的情况：</p><ul><li>一个进程在没有先获得资源访问权限就访问资源</li><li>一个进程在获得资源访问权限之后就不释放资源</li><li>一个进程视图释放一个从来没有请求的资源</li><li>一个进程可能请求同一资源两次（中间没有释放资源）</li></ul><h3 id="同步实例"><a class="anchor" href="#同步实例">#</a> 同步实例</h3><h4 id="pthread-同步"><a class="anchor" href="#pthread-同步">#</a> Pthread 同步</h4><p>Pthread API 为线程同步提供：</p><ul><li>互斥锁（Pthread 的基本同步技术，保护临界区代码）</li><li>条件变量</li></ul><p>不可移植的扩展：</p><ul><li>自旋锁</li><li>读写锁</li></ul><h3 id="原子事务"><a class="anchor" href="#原子事务">#</a> 原子事务</h3><p>这一部分在数据库管理原理与设计系统的事务部分有详细介绍</p><h2 id="第-7-章-死锁"><a class="anchor" href="#第-7-章-死锁">#</a> 第 7 章 死锁</h2><h3 id="系统模型"><a class="anchor" href="#系统模型">#</a> 系统模型</h3><p>系统拥有一定数量的资源，分布在若干竞争进程之间。资源可以分成多种类型，每种类型有一定数量的实例。</p><p>同类型的资源：一个进程申请某个资源类型的一个实例，同类的任何实例都可以满足要求，那么就是相同的。</p><p>进程使用资源的<strong>流程</strong>:</p><ul><li>申请：如果不被允许，那么就必须等待，直到允许</li><li>使用</li><li>释放</li></ul><p>当一组进程中的每个进程都在等待一个事件，而这个事件只能由这一组进程的另一进程引起，那么这组进程就处于死锁状态</p><h3 id="死锁特征"><a class="anchor" href="#死锁特征">#</a> 死锁特征</h3><h4 id="必要条件"><a class="anchor" href="#必要条件">#</a> 必要条件</h4><ul><li>互斥 Mutual exclusion： 至少有一个资源处于非共享模式。</li><li>占有并等待 Hold and wait：一个进程必须占有至少一个资源，并等待另一资源（被其他进程占有）</li><li>非抢占 No preemption： 资源不能被抢占，只能等待自动释放</li><li>循环等待 Circular wait：一组等待进程 P0,P1,..,PnP0,P1,..,Pn 一个进程的等待资源被下一个进程占用</li></ul><p>四个条件必须<strong>同时满足</strong>才会出现死锁。循环等待意味者占有并等，这四个条件并不是完全独立。</p><h4 id="资源分配图"><a class="anchor" href="#资源分配图">#</a> 资源分配图</h4><p>Resource-Allocation Graph</p><p>节点类型：</p><ul><li>系统活动进程的集合（圆形）</li><li>系统所有资源类型的集合（一个矩形表示一类资源，里面的点表示资源）</li></ul><p>边：</p><ul><li>申请边：进程指向资源</li><li>分配边：资源指向进程</li></ul><p>如果分配图没有环，那么系统就没有进程死锁。如果有，那么就<strong>可能</strong>存在死锁</p><p>如果<strong>每个资源类型刚好有一个实例</strong>，那么<strong>有环</strong>就意味着出现了死锁。</p><h3 id="死锁处理方法"><a class="anchor" href="#死锁处理方法">#</a> 死锁处理方法</h3><ul><li>使用协议预防或避免死锁</li><li>允许系统进入死锁状态，然后检测它，并加以恢复</li><li>忽视这个问题，认为死锁不可能发生</li></ul><p>然而绝大多数系统使用第三种方法，这就需要我们自己处理死锁。</p><p>死锁预防， deadlock prevention ： 确保至少一个必要条件不成立，通过限制如果申请资源的方法来预防</p><p>死锁避免， deadlock avoidance： 操作系统事先得到有关进程申请资源和使用资源的额外信息，然后确定对于一个申请是否应该等待。</p><h3 id="死锁预防"><a class="anchor" href="#死锁预防">#</a> 死锁预防</h3><p>只要确保至少一个必要条件不成立。</p><h4 id="互斥"><a class="anchor" href="#互斥">#</a> 互斥</h4><p>使用共享资源，比如只读文件，不过有些资源本身就是非共享的。</p><h4 id="占有并等待"><a class="anchor" href="#占有并等待">#</a> 占有并等待</h4><p>保证当一个进程申请一个资源时，他<strong>不能占有其他资源</strong>。</p><ul><li>在每个进程执行前申请并获得<strong>所有</strong>的资源。</li><li>运行进程在没有资源时才能申请资源，也就是在申请更多资源时候<strong>必须释放当前资源</strong></li></ul><p>缺点：</p><ul><li>资源利用率 (resource utilization) 可能比较低</li><li>可能发生饥饿</li></ul><h4 id="非抢占"><a class="anchor" href="#非抢占">#</a> 非抢占</h4><p>使用协议：如果一个进程占有资源并申请另一个<strong>不能立即分配</strong>的资源，那么其现已分配的资源<strong>都可以被抢占</strong>。也就是说这些资源被隐式释放了。当进程获得其原有资源和所申请的新资源时，才能重新执行。</p><p>适用于<strong>状态可以保存和恢复的资源</strong>，如 CPU 寄存器，内存，但不适用于打印机和磁带驱动器。</p><h4 id="循环等待"><a class="anchor" href="#循环等待">#</a> 循环等待</h4><p>对所有资源类型进行完全排序，并<strong>按递增顺序</strong>申请资源。</p><p>使用协议：</p><blockquote><p>每个进程只按递增顺序申请资源，如果需要同一资源类型的多个实例，那么必须同时申请。</p><p>当一个进程需要前面的资源时，必须<strong>释放后面</strong>的资源。</p></blockquote><p>这样一来，循环等待就不可能成立。</p><p>我们可以使用锁顺序验证器，检测是否可能出现死锁</p><h3 id="死锁避免"><a class="anchor" href="#死锁避免">#</a> 死锁避免</h3><p>使用死锁预防会带来<strong>低设备使用率和系统吞吐率</strong></p><p>因此我们可以获得以后如何申请资源的附加信息，然后决定进程是否因申请而等待。</p><p>每次申请要求系统考虑现有可用资源，现已分配给每个进程的资源和每个进程将来申请与释放的资源，以决定当前申请是否满足或必须等待，从而避免死锁发生的可能性。</p><p>最简单的模型：要求每个进程说明他们可能需要的每种资源实例的最大需求，构造一个算法确保系统绝不会进入死锁状态</p><p><strong>死锁避免</strong> (deadlock-avoidance) 算法动态地检测<strong>资源分配状态</strong>以确保循环等待条件不可能成立。</p><p>资源分配状态由以下数据决定：</p><ul><li>可用资源</li><li>已分配资源</li><li>进程最大需求</li></ul><h4 id="安全状态"><a class="anchor" href="#安全状态">#</a> 安全状态</h4><p>安全：系统能按某个顺序为每个进程分配资源（不超过其最大值）并能避免死锁</p><p>也就是：存在一个<strong>安全序列</strong></p><p>安全序列：</p><p>对于每个进程，进程仍然可以申请的资源数小于当前可用资源加上序列前面的资源所占用的资源。</p><p>不安全状态<strong>可能</strong>导致死锁</p><p>避免算法的思想：简单地确保系统<strong>始终</strong>处于<strong>安全状态</strong></p><h4 id="资源分配图算法"><a class="anchor" href="#资源分配图算法">#</a> 资源分配图算法</h4><p>引入一个需求边：表示某个进程在将来每个时刻申请某个资源（用虚线表示）</p><p>当进程申请资源的时候，需求边就变成申请边</p><p>当进程释放资源的时候，申请边就变成需求边</p><p>只有当需求边变成申请边的时候<strong>没有环</strong>，才允许申请。</p><p>不适用于每种资源由<strong>多个实例</strong>的资源分配系统</p><h4 id="银行家算法"><a class="anchor" href="#银行家算法">#</a> 银行家算法</h4><p>对于每种资源有多个实例的资源分配系统。</p><p>当新进程进入系统，必须说明其可能需要的<strong>最大资源实例数</strong>。当用户申请一组资源时，系统必须确定这些资源的分配是否仍会使系统处于安全状态，如果是，就分配资源，否则，必须等待直到某个其他进程释放足够资源为止。</p><p>定义以下数据结构</p><ul><li>Available：表示每种资源的现有实例数量</li><li>Max： 表示每个进程的最大需求</li><li>Allocation： 每个进程限制所分配的各种资源类型的实例数量</li><li>Need：每个进程还需要的剩余资源</li></ul><p>Need[i,j]=Max[i,j]−Allocation[i,j]Need[i,j]=Max[i,j]−Allocation[i,j]</p><h5 id="安全性算法"><a class="anchor" href="#安全性算法">#</a> 安全性算法</h5><p>确定计算机系统是否处于安全状态</p><ul><li>定义变量 <code>Work = Available， finish[i] = false;</code></li><li>查找满足 <code>finish[i] = false &amp;&amp; Needi &lt;= Work</code> 的 <code>i</code> ， 如果没有，就跳转到第 4 步</li><li><code>Work += Allocation; finish[i] = true</code> , 返回第 2 步</li><li>如果所有的 <code>i</code> 满足 <code>finish[i] = true</code> 则系统安全</li></ul><p>一共需要 m×n2m×n2 的操作</p><h5 id="资源请求算法"><a class="anchor" href="#资源请求算法">#</a> 资源请求算法</h5><ul><li>如果 Requsett≤NeediRequsett≤Needi 跳到第二步，否则出错</li><li>如果 Requsett≤AvailableRequsett≤Available 跳到第三部，否则需要等待</li><li>如果可以分配，那么修改状态<ul><li>Available=Available−RequestiAvailable=Available−Requesti</li><li>Allocationi=Allocationi+RequsetiAllocationi=Allocationi+Requseti</li><li>Needi=Needi−RequestiNeedi=Needi−Requesti</li></ul></li></ul><h3 id="死锁检测"><a class="anchor" href="#死锁检测">#</a> 死锁检测</h3><ul><li>允许系统进入死锁状态</li><li>检查系统状态从而确定是否出现锁的算法</li><li>从死锁状态恢复的算法</li></ul><h4 id="每种资源类型只有单个实例"><a class="anchor" href="#每种资源类型只有单个实例">#</a> 每种资源类型只有单个实例</h4><p>等待图：从资源分配图中，删除所有资源类型节点， 合并适当边。</p><p>当且仅当等待图中有一个环，系统存在死锁。</p><h4 id="每种资源类型可有多个实例"><a class="anchor" href="#每种资源类型可有多个实例">#</a> 每种资源类型可有多个实例</h4><p>类似于银行家算法，只有有一个不满足就是处于死锁状态</p><h4 id="应用检测算法"><a class="anchor" href="#应用检测算法">#</a> 应用检测算法</h4><p>何时调用检测算法，取决于</p><ul><li>死锁可能发生频率</li><li>死锁发生时受影响进程的数量</li></ul><p>如果进程发生死锁，就应该经常调用检测算法。</p><h3 id="死锁恢复"><a class="anchor" href="#死锁恢复">#</a> 死锁恢复</h3><ul><li>终止一个或多个进程</li><li>从一个或多个死锁进程那里抢占一个或多个资源</li></ul><h4 id="进程终止-2"><a class="anchor" href="#进程终止-2">#</a> 进程终止</h4><ul><li>终止所有死锁进程</li><li>一次只终止一个，直到取消死锁循环为止（开销较大），应该终止代价最小的进程，判断因素：<ul><li>进程优先级</li><li>进程计算了多久，还需多久</li><li>使用了多少，什么类型的资源</li><li>需要多少资源能完成</li><li>多少进程需要被中止</li><li>进程是交互的还是批处理</li></ul></li></ul><h4 id="资源抢占"><a class="anchor" href="#资源抢占">#</a> 资源抢占</h4><ul><li>选择一个牺牲品（代价最小化）</li><li>回滚<ul><li>完全回滚： 终止进程并重新执行</li><li>回滚到足够打破死锁</li></ul></li><li>饥饿<ul><li>确保一个进程只能有限地被选择为牺牲品</li></ul></li></ul><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3><p>三种处理死锁的方法:</p><ul><li>使用一些协议来预防或避免死锁，确保系统不会进入死锁状态</li><li>允许系统进入死锁状态，检测死锁，并恢复</li><li>忽略这个问题</li></ul><p>当且仅当 4 个必要条件同时成立才会发生死锁， 确保则 4 个必要条件不成立可以预防死锁</p><p>死锁避免算法比预防算法要求低</p><p>检测到死锁，系统通过终止某些死锁进程或抢占某些死锁进程的资源来从死锁中恢复</p><p>抢占时需要考虑： 选择一个牺牲品、回滚和饥饿</p><h1 id="第三部分-内存管理"><a class="anchor" href="#第三部分-内存管理">#</a> 第三部分 内存管理</h1><h2 id="第-8-章-内存管理"><a class="anchor" href="#第-8-章-内存管理">#</a> 第 8 章 内存管理</h2><h3 id="背景"><a class="anchor" href="#背景">#</a> 背景</h3><ul><li>基本硬件概述</li><li>符号内存地址到实际物理地址的绑定</li><li>逻辑地址与物理地址的差别</li><li>动态装载</li><li>动态链接代码及共享库</li></ul><h4 id="基本硬件"><a class="anchor" href="#基本硬件">#</a> 基本硬件</h4><p>CPU 在使用数据前必须先把数据移到内存中</p><p>然而 CPU 访问内存通常需要多个时钟周期，内存访问频繁，经常需要暂停 (stall)，因此加入了高速缓存 (cache)</p><p>内存需要确保操作系统不被用户进程访问，可通过硬件实现。</p><p>确保每个进程都有独立的内存空间，需要确定进程可访问的合法地址的范围，并确保进程只访问其合法地址。通过基地址寄存器和界限地址寄存器实现。</p><ul><li>基地址寄存器 base register：最小的合法物理内存地址</li><li>界限地址寄存器 limit register： 范围的大小</li></ul><p>内存空间保护：通过 CPU 硬件对用户模式所产生的每一个地址与寄存器的地址进行比较。当用户模式下执行的程序试图访问非自己的内存，就会当成错误处理。</p><p>只有操作系统在内核模式下才能修改这两个寄存器</p><h4 id="地址绑定"><a class="anchor" href="#地址绑定">#</a> 地址绑定</h4><p>输入队列 (input queue)： 在磁盘上等待调入内存以执行的进程。</p><ul><li><p>编译时 (compile time): 在编译时就知道进程在内存中驻留地址，生成绝对代码。如 DOS 的 COM 程序</p></li><li><p>加载时 (load time)：可重定位代码 (relocatable code)， 绑定会延迟到加载时 [</p><p>静态地址重定位</p><p>]</p><ul><li>无须硬件支持</li><li>重定位以后不能在内存中移动</li><li>要求存储空间是连续的</li></ul></li><li><p>执行时 (execution time)：进程可以在执行时从一个内存段移到另一个内存段，绑定延迟到执行时执行，绝大多数操作系统采用的方法（需要硬件支持，mmu）[<strong>动态地址重定位</strong>]</p></li></ul><h4 id="逻辑地址空间与物理地址空间"><a class="anchor" href="#逻辑地址空间与物理地址空间">#</a> 逻辑地址空间与物理地址空间</h4><p>逻辑地址 (logical address)： CPU 所生成的地址（也称虚拟地址）</p><p>物理地址 (physical address)：内存单元所看到的地址（加载到内存地址寄存器 (memory-address register) 中的地址）</p><p>编译和加载时绑定方法中：逻辑地址 = 物理地址</p><p>执行时地址绑定：逻辑地址！= 物理地址</p><p><strong>逻辑地址空间</strong> (logical address space)：由程序生成的所有逻辑地址的集合</p><p><strong>物理地址空间</strong> (physical address space)：逻辑地址相对应的所有物理地址的集合</p><p>内存管理单元 (memory-management unit, MMU)： 管理运行时从虚拟地址到物理地址的映射。</p><p>基地址寄存器作为重定位寄存器 (relocation register)， 用户进程所生成的地址在交送内存之前，都将加上重定位寄存器的值。</p><p>用户程序处理逻辑地址，内存映射硬件将逻辑地址转变为物理地址。</p><h4 id="动态加载"><a class="anchor" href="#动态加载">#</a> 动态加载</h4><p>一个子程序只有在调用时才被加载。</p><p>优点：</p><ul><li>不用的子程序不会被加载。</li><li>更好的内存占用</li><li>不需要操作系统的特殊支持</li></ul><p>覆盖技术：</p><p>先后调入程序段到同一内存的空间</p><h4 id="动态链接与共享库"><a class="anchor" href="#动态链接与共享库">#</a> 动态链接与共享库</h4><p>静态链接，由加载程序合并到二进制程序镜像中</p><p>动态链接：</p><ul><li>装入时链接<ul><li>使用动态库导入表</li></ul></li><li>运行时链接<ul><li>使用 API 装入动态库</li><li>优点：<ul><li>共享</li><li>部分装入</li><li>便于局部代码修改</li><li>便于运行环境适应</li></ul></li><li>缺点：<ul><li>链接开销</li><li>管理开销</li></ul></li></ul></li></ul><p>被链接的共享代码称为动态链接库 (DLL, Dynamic-Link Library) 或共享库 (shared library)</p><p>二进制镜像对每个库程序的应用都有个存根 (stub)， 用于指出如果定位适当的内存驻留库程序，如果程序不在内存如何装入内存。</p><p>优点： 占用体积小， 方便更新。</p><h3 id="交换"><a class="anchor" href="#交换">#</a> 交换</h3><p>进程暂时从内存中交换 (swap) 到备份存储 (backing store) 上，当需要再次执行时调回到内存中。</p><p>备份存储 (backing store)：快速大容量的存储设备，可以直接访问</p><p>滚出和滚入：内存管理器交换出低优先级的进程， 装入高优先级进程</p><p>交换时间的主要部分是传输时间</p><p>总传输时间与内存交换量成正比。</p><h3 id="连续内存分配"><a class="anchor" href="#连续内存分配">#</a> 连续内存分配</h3><p>contiguous memory allocation</p><p>内存通常分为两个部分：</p><ul><li>预留给操作系统的低地址部分（含有中断向量表）</li><li>用户进程的高地址部分</li></ul><h4 id="内存映射与保护"><a class="anchor" href="#内存映射与保护">#</a> 内存映射与保护</h4><p>通常使用重定位寄存器和界限地址寄存器实现</p><p>重定位寄存器含有最小的物理地址值</p><p>界限地址寄存器含有逻辑地址的范围值</p><p>MMU 动态地将逻辑地址加上重定位寄存器的值映射为物理地址，再移交给内存单元</p><p>重定位机制为操作系统提供了灵活性，可以动态改变操作系统大小（驱动的加载）</p><h4 id="内存分配"><a class="anchor" href="#内存分配">#</a> 内存分配</h4><p><strong>多分区方法</strong>：将内存分为多个固定大小的分区 (partition)，每个分区只能容纳一个进程</p><p>当一个分区空闲，就从输入队列中选择一个进程，调入到空闲分区</p><p><strong>可变分区</strong>：使用一个表记录哪些内存可用和已占用。一大块可用内存称为<strong>孔 (hole)</strong></p><p>动态存储分配问题：</p><p>常用方法： 首次适应 (frist-fit)、最佳适应 (best-fit)、最差适应 (worst-fit)</p><ul><li>首次适应 First-fit： 分配第一个足够大孔，查找可以从头开始，也可以从上次首次适应结束时开始，一旦找到足够大的空闲孔，就可以停止</li><li>最佳适应 Best-fit： 分配最小足够大的孔。必须查找整个列表，可以产生最小剩余孔</li><li>最差适应 Worst-fit： 分配最大的孔。必须查找整个列表，可以产生最大剩余孔。</li></ul><p>首次适应和最佳适应的执行时间和利用空间都好于最差适应。首次适应方法最快。最差适应可以预留较大的孔。</p><h4 id="碎片"><a class="anchor" href="#碎片">#</a> 碎片</h4><p>首次适应和最佳适应都会导致<strong>外部碎片问题</strong> (当所有总的可用内存之和可以满足请求，但不连续)</p><p>**50%** 规则： 对采用首次适应方法，不管使用什么优化，假定由 N 个可分配块， 那么可能由 0.5N 个外部碎片，及 1/3 的内存可能不能使用</p><p><strong>内部碎片</strong>：在分配块内的空间</p><p>解决外部碎片的一个方法： 紧缩 (compaction)</p><p>移动内存的内容，以便所有空闲空间合并成一整块。紧缩仅在重定位是<strong>动态并在运行时</strong>可采用。</p><p>最简单的合并算法：简单地将所有进程移到内存的一段，而将所有的孔移动到内存的另一端， 以生成一个大的空闲块。这种方案<strong>开销较大</strong></p><p>另一个解决方法：允许物理地址空间为非连续。</p><h3 id="分页"><a class="anchor" href="#分页">#</a> 分页</h3><p>paging， 分页内存管理方案允许进程的物理地址空间可以时非连续的。</p><h4 id="基本方法"><a class="anchor" href="#基本方法">#</a> 基本方法</h4><p>将物理内存分为固定大小的块，称为帧 (frame)， 将逻辑内存页分为同样大小的块， 称为页 (page)</p><p>当需要执行进程时， 其页从备份存储中调入到可用的内存帧中。</p><p>硬件支持：</p><p>由 CPU 生成的每个地址分为两个部分，<strong>页号</strong> (p) 和<strong>页偏移</strong> (d)。 页号作为页表中的索引。页表包含每页所在物理内存的基地址，与页偏移组合形成物理地址。</p><p>分页没有外部碎片，但是还是有内部碎片。</p><p>分页的一个重要的特点时用户视角的内存和实际的物理内存的分离。</p><p>帧表 (frame table) 中， 保存着物理存你的分配细节， 每个条目对应一个帧。</p><p>分页增加的<strong>切换时间</strong>。</p><h4 id="硬件支持"><a class="anchor" href="#硬件支持">#</a> 硬件支持</h4><p>页表的硬件实现，最简单的方法:</p><p>将页表作为一组专用寄存器来实现。</p><p>当页表比较大的时候，将页表放在<strong>内存</strong>中，</p><p>** 页表基寄存器 (page-table base register, PTBR)** 指向页表</p><p>** 页表长度寄存器 (Page-table length register, PRLR)** 表明页表的大小。</p><p>不过需要两次内存访问， 内存访问速度减半。</p><p>标准解决方案： 使用小但是专业且快速的硬件缓冲，称为<strong>转换表缓冲区 (translation look-aside buffer, TLB</strong>, 是关联的快速内存，由键（标签）和值组成。</p><p>不过 TLB 中条目数不多，只包括页表中的一小部分，如果页码不再 TLB 中 (TLB 失效)，那么就需要访问页表，然后把页号和帧号存到 TLB 中，如果 TLB 已满， 就是用最少使用替换 (LRU) 或随机替换。并且允许有些条目固定下来。</p><p>TLB 中还保存<strong>地址空间标识符 (address-space identifier, ASID</strong> , 可用来唯一标识进程，为其提供地址空间保护。保证当前运行进程的 ASIO 与虚拟页中 ASID 相匹配，如果不匹配就失效处理。如果不支持 ASID， 那么上下文切换的时候，TLB 就需要被冲刷 (flushed) 或删除。</p><p>页号在 TLB 中被查找到的百分比称为<strong>命中率</strong></p><p>有效访问时间 Effective Access Time（EAT）= 访问内存时间 _ 命中率 + （1 - 命中率）_ （访问页面 + 访问内存时间）</p><h4 id="保护"><a class="anchor" href="#保护">#</a> 保护</h4><p>分页环境下， 内存保护是通过每个帧相关的保护位（保存在页表中）来实现的。</p><p>使用一个位来定义一个页是可读写还是只读的</p><p>使用<strong>有效位和无效位</strong>可以捕捉到非法地址</p><h4 id="共享页"><a class="anchor" href="#共享页">#</a> 共享页</h4><p>分页的优点之一在于可以共享公共代码</p><h3 id="页表结构"><a class="anchor" href="#页表结构">#</a> 页表结构</h3><h4 id="层次页表"><a class="anchor" href="#层次页表">#</a> 层次页表</h4><p>对于非常大的页表，可以将其划分为更小部分</p><p>划分方法一： 两级分页算法，将页表再分页。逻辑地址由 {P1, P2, d} 组成， 也称为<strong>向前映射页表 (forward-mapped page table)</strong></p><h4 id="哈希页表"><a class="anchor" href="#哈希页表">#</a> 哈希页表</h4><p>处理超过 32 位的地址空间常用哈希页表， 并以虚拟页码作为哈希值。</p><p>哈希表中每个元素由 3 个域:</p><ul><li>虚拟页码</li><li>所映射的帧号</li><li>链表中下一个元素的指针</li></ul><p>变种： <strong>群集页表</strong> (clustered page table)， 适合 64 位，对于稀疏地址空间特别有用</p><p>每一条目包括多页，一个页表条目可以存储多个物理页帧的映射。</p><h4 id="反向页表"><a class="anchor" href="#反向页表">#</a> 反向页表</h4><p>通常情况下， 每个进程都有一个相关页表。页表是按照虚拟地址排序的，操作系统计算出对应条目在页表中的位置，并可以直接使用该值。那样就存在一个缺点：每个页表可能有很多项，可能会消耗大量的物理内存，却仅仅用于跟踪物理内存如何使用。</p><p>反向页表，inverted page table， 对于每个真正的内存页或帧才有一个条目。每个条目包括保存在真正内存位置的页的虚拟地址以及拥有该页的进程的信息。</p><p>这种方案减少了存储每个页表所需要的内存空间，但是增加了查找页表所需要的时间。</p><p>反向页表按物理地址排序， 而查找是根据虚拟地址，因此可能需要查找整个表来寻求匹配。可以使用哈希页表 + TLB 来优化。</p><p>而且反向页表实现共享内存比较困难，不能实现被映射到一个物理地址多个虚拟地址。</p><h3 id="分段"><a class="anchor" href="#分段">#</a> 分段</h3><p>分页管理内存的问题：用户视角的内存和实际物理内存的分离。</p><h4 id="基本方法-2"><a class="anchor" href="#基本方法-2">#</a> 基本方法</h4><p>分段 (segmentation) 是支持用户视角的内存管理方案。逻辑地址空间是由一组段组成的。每个段都有名称和长度。地址指定了段名称和段内偏移。</p><p>用户通过段名称和偏移来指定地址。</p><h4 id="硬件"><a class="anchor" href="#硬件">#</a> 硬件</h4><p>段表 (segment table) 实现将二维的用户定义定制映射为一维的物理地址。段表的每个条目都有<strong>段基地址（STBR）和段界限 (STLR)</strong>。段基地址包含该段在内存中开始的物理地址，段界限指定该段的长度。</p><p>逻辑地址由：段号 s 和段内偏移 d 组成。</p><p>MULTICS 系统通过<strong>分页</strong>来解决外部碎片和冗长搜索时间的问题。</p><p>段表条目不包含段的基地址，而是包含此段的页表的基地址。</p><h2 id="第-9-章-虚拟内存"><a class="anchor" href="#第-9-章-虚拟内存">#</a> 第 9 章 虚拟内存</h2><h3 id="背景-2"><a class="anchor" href="#背景-2">#</a> 背景</h3><p>能够执行只有部分在内存中的程序的好处：</p><ul><li>程序不再受现有的物理内存空间的限制，用户可以为一个巨大的虚拟地址空间编写程序，简化了变成工作量</li><li>每个用户程序使用了更少物理内存，更多的程序可以同时运行，增加了 CPU 使用率。</li><li>载入或交换每个用户程序到内存内所需的 I/O 变少。</li></ul><p>虚拟内存 (virtual memory) 将用户逻辑内存与物理内存分开。</p><p>进程的虚拟地址空间就是进程如何在内存中存放的逻辑 (或虚拟) 视图</p><p>随着动态内存的分配，对可以向上生长，随着子程序的不断调用，栈可以向下生长，堆栈之间的巨大空白空间为虚拟地址的一部分。称为稀地址空间。</p><p>虚拟内存也允许文件和内存通过共享页而为两个或多个进程所共享。优点：</p><ul><li>将共享对象映射到虚拟地址空间，系统库可为多个进程所共享</li><li>虚拟内存允许进程共享内存</li><li>允许在用系统调用 <code>fork</code> 创建进程期间共享页，从而加快进程的创建</li></ul><h3 id="按需调页"><a class="anchor" href="#按需调页">#</a> 按需调页</h3><p>demand paging, 在需要的时时候才调入相应的页。</p><p>好处:</p><ul><li>更少的 I/O</li><li>更少的内存需求</li><li>更快的响应</li><li>更多的用户</li></ul><p>按需调用类似于使用交换的分页系统，进程驻留在第二季存储器上。使用懒惰交换 (lazy swapper)</p><p>区别：</p><ul><li>交换对整个进程进程操作</li><li>调页程序 (paper)，只对进程的单个页进程操作。</li></ul><h4 id="基本概念-2"><a class="anchor" href="#基本概念-2">#</a> 基本概念</h4><p>换入进程时，调页程序推测在该进程再次换出之前会用到哪些页。把必须的页调入进程，避免了读入不使用的页，减少了交换时间和所需物理内存空间。</p><p>使用 ** 有效 - 无效位 (valid0invalid bit)** 区分哪些页在内存里。</p><p>当进程视图访问尚未调入到内存的页， 就会产生<strong>页错误陷阱 (page-fault trap)</strong>。</p><p>处理错误的程序：</p><ul><li>检查进程的内部页表，以确定该引用是合法还是非法的地址访问</li><li>如果引用非法，那么就中止进程。如果引用有效但是尚未调入页面，那么现在调入</li><li>找到一个空闲帧<ul><li>如果没有空闲帧，使用页面置换</li></ul></li><li>调度一个磁盘操作，一般从所需要的页调入刚分配的帧</li><li>当磁盘读操作完成后， 修改进程的内部表和页表，以表示该页已经在内存中。</li><li>重新开始因陷阱而中断的指令。</li></ul><p><strong>纯粹按需调页 (pure demand paging)</strong></p><p>一开始所有的页都不在内存中，只有在需要时才将页调入内存。</p><p>程序应具有<strong>局部引用 (locality of reference)</strong>，才能使得按需调页性能较为合理。</p><p>支持按需调页的硬件:</p><ul><li>页表：通过有效 - 无效位或保护位的特定值，将条目设为无效</li><li>次级存储器：保护不再内存中的页。称为<strong>交换空间 (swap space)</strong></li></ul><p>请求调页的关键要求：在页错误后重新执行指令。</p><p>主要困难：一个指令可能改变多个不同的位置或者源和目的块由重叠。当指令执行到一半的时候，页错误后不能简单地再次执行该指令。</p><p>解决方案：</p><ul><li>微码计算并试图访问两块的两端，先检测是否有页错误再执行移动。</li><li>使用临时寄存器来保存覆盖位置的值</li></ul><h4 id="按需调页的性能"><a class="anchor" href="#按需调页的性能">#</a> 按需调页的性能</h4><p>有效访问时间 = (1−p)×ma (内存访问时间)+p× 页错误时间 (1−p)×ma (内存访问时间)+p× 页错误时间</p><p>主要页错误处理时间：</p><ul><li>处理页错误中断</li><li>读入页</li><li>重新启动进程</li></ul><p>按需调页的另一个重要方面是交换空间的处理和使用。如果进程开始将整个文件镜像复制到交换空间，并从交换重建执行按页调度，效果会更好。也可以从文件系统中按需调页到交换空间。</p><h3 id="写时复制"><a class="anchor" href="#写时复制">#</a> 写时复制</h3><p>Copy-on-Write, COW</p><p>这种方法允许父进程与子进程开始时共享同一页面。这些页面标记为写时复制页， 即如果任何一个进程需要对页进行写操作，那么就创建一个共享页的副本</p><p>从空闲缓冲池分配空闲页，用<strong>按需填零 (zero-fill-on-demand)</strong> (在分配前先填 0，清除以前的内容) 分配页。</p><p><code>vfork()</code> ：将父进程挂起， 子进程使用父进程的地址空间。</p><h3 id="页面置换"><a class="anchor" href="#页面置换">#</a> 页面置换</h3><p>如果增加了多道程序，那么会过度分配 (over-allocating)</p><p>操作系统可以交换出一个进程，释放其所有帧，降低多道程序的基本。</p><h4 id="基本页置换"><a class="anchor" href="#基本页置换">#</a> 基本页置换</h4><ul><li>查找所需页在页面上的位置</li><li>查找一个空闲帧<ul><li>如果有空闲帧，使用它</li><li>如果没有，那么就使用页置换算法选择一个<strong>牺牲帧 (victim frame)</strong></li><li>将牺牲帧写入磁盘，改变页表和帧表</li></ul></li><li>将所需页读入新的空闲帧，改变页表和帧表</li><li>重启用户进程</li></ul><p>可以通过 ** 修改位 (modify bit)<strong> 或</strong>脏位 (dirty bit)** 以降低额外开销。以决定牺牲帧是否需要写到磁盘上去。</p><p>需要<strong>帧分配算法 (frame-allocation algorithm)<strong> 和</strong>页置换算法 (page-replacement algorithm)</strong></p><p>置换算法：通常使用最小页错误率的算法</p><h4 id="fifo-页置换"><a class="anchor" href="#fifo-页置换">#</a> FIFO 页置换</h4><p>最简单的页置换方法。</p><p><strong>Belady 异常 (Belady’s anomaly)</strong>：对有的页置换算法，页错误率可能会随着所分配的帧数的<strong>增加而增加</strong>。</p><p>FIFO 算法容易实现，但是所替代的页可能包含一个以前初始化并且不断使用常用变量。</p><h4 id="最优置换"><a class="anchor" href="#最优置换">#</a> 最优置换</h4><p>optimal page-replacement algorithm</p><p>搜索所产生的<strong>页错误率是最低的</strong>，且绝没有 Belady 异常问题。</p><p>称为 OPT 或 MIN，置换<strong>最长时间不会使用</strong>的页。</p><p>难点：需要引用串的未来知识。</p><h4 id="lru-页置换"><a class="anchor" href="#lru-页置换">#</a> LRU 页置换</h4><p>最近最少使用算法 (least-recently-used (LRU) algorithm)</p><p>LRU 选择<strong>最长时间没有使用的页</strong>来置换。</p><p>实现方法：</p><ul><li>计数器：为每个页表项关联一个使用时间域，并为 CPU 增加一个逻辑时钟或计数器。每次内存引用，计数器都增加，并且时钟寄存器内容会被复制到相应页所对应页表项的使用时间域内。置换具有最小时间的页。每次都需要搜索页表并且写入内存，页表改变页需要保持时间。</li><li>栈：每引用一个页，就该页从栈中删除并放到顶部。</li></ul><p>没有 Belady 异常，和最优置换属于同一类算法 (栈算法)</p><p>如果每次引用都需要中断，就使得内存引用慢至少 10 倍，因此需要硬件支持。</p><h4 id="近似-lru-页置换"><a class="anchor" href="#近似-lru-页置换">#</a> 近似 LRU 页置换</h4><p>LRU Approximation Algorithms</p><p>使用引用位</p><h5 id="附加引用位算法"><a class="anchor" href="#附加引用位算法">#</a> 附加引用位算法</h5><p>为位于内存内的每个表中的页保留一个 8 位的字节，再规定时间间隔内，将引用位转移到 8 位字节的高位，然后其他位右移。8 位字节的无符号整数<strong>最小值</strong>的页为 LRU 页，可以被置换。</p><p>如果历史位降为 0，就是<strong>第二次机会页置换算法 (second-chance page-replacement algorithm)</strong></p><h5 id="二次机会算法"><a class="anchor" href="#二次机会算法">#</a> 二次机会算法</h5><p>基本算法还是 FIFO 算法，当引用位为 1 时，给该页第二次机会，并将引用位清零。</p><p>如果所有位被设置为 1，那就是 FIFO 置换</p><p>一种实现方法就是使用循环队列。</p><h5 id="增强型二次机会算法"><a class="anchor" href="#增强型二次机会算法">#</a> 增强型二次机会算法</h5><p>使用引用位和修改位作为有序对</p><ul><li>(0, 0): 用于置换最佳页</li><li>(0, 1): 最近没有使用但是修改过，不是很好</li><li>(1, 0): 最近使用过但是没有修改，可能很快被使用</li><li>(1, 1)</li></ul><p>检查页的类型，置换最低非空类中的页。</p><p>给<strong>修改过的页</strong>更高的级别，降低所需 I/O</p><h4 id="基于计数的页置换"><a class="anchor" href="#基于计数的页置换">#</a> 基于计数的页置换</h4><h5 id="最不经常使用页置换算法"><a class="anchor" href="#最不经常使用页置换算法">#</a> 最不经常使用页置换算法</h5><p>least frequently used(LFU) page-replacement algorithm</p><p>置换计数最小的页，并且定期将次数寄存器有移，<strong>指数衰减</strong>平均使用次数</p><h5 id="最常使用页支援算法"><a class="anchor" href="#最常使用页支援算法">#</a> 最常使用页支援算法</h5><p>most frequently used(MFU)page-replacement-algorithm</p><p>具有最小次数可能刚刚调进来，还没有使用。</p><h4 id="页缓冲算法"><a class="anchor" href="#页缓冲算法">#</a> 页缓冲算法</h4><p>系统通常保留一个空闲帧缓冲池，无需等待牺牲帧写出，就可以尽可能快地重启。</p><p>或者保留一个空闲帧池，发生页错误时可以先搜索空闲帧池，此时不需要 I/O</p><h4 id="应用程序与页置换"><a class="anchor" href="#应用程序与页置换">#</a> 应用程序与页置换</h4><p>有的操作系统允许特殊程序将磁盘作为逻辑块数组使用，不需要通过文件系统，称为<strong>生磁盘 (raw disk)</strong> ，对数组的 I/O 称为<strong>生 I/O</strong></p><p>应用程序可以使用适合自己的置换模式。</p><h3 id="帧分配"><a class="anchor" href="#帧分配">#</a> 帧分配</h3><h4 id="帧的最少数量"><a class="anchor" href="#帧的最少数量">#</a> 帧的最少数量</h4><p>帧分配策略受到的限制:</p><ul><li>所分配的帧不能超过可用帧的数量</li><li>必须分配至少最少数量的帧<ul><li>性能</li><li>必须有足够的帧来容纳所有单个指令所引用的页</li></ul></li></ul><p>每个进程帧的最少数量是由体系结构决定，而最大数量是由物理内存的数量来决定的。</p><h4 id="分配算法"><a class="anchor" href="#分配算法">#</a> 分配算法</h4><ul><li>固定分配 fixed allocation<ul><li>平均分配 (equal allocation)： n 个进程之间分配 m 帧， 每个进程 mnmn 帧</li><li>比例分配 (Proportional allocation)：根据进程大小，将可用内存分配给每个进程。</li></ul></li><li>优先级分配 priority allocation<ul><li>一开始使用比例分配</li><li>如果进程发生页错误，可以从低优先级的进程选择帧置换</li></ul></li></ul><h4 id="全局分配与局部分配"><a class="anchor" href="#全局分配与局部分配">#</a> 全局分配与局部分配</h4><p>全局置换：从所有帧集合中选择一个置换帧（问题：进程不能控制其页错误率，但是具有更好的系统吞吐量，可以使用其他进程不常用的内存）</p><p>局部置换：从自己分配帧中进行选择</p><h3 id="系统颠簸"><a class="anchor" href="#系统颠簸">#</a> 系统颠簸</h3><p>Thrashing， 进程没有足够的页，发生频繁的页调度行为，在换页上用的时间要多于执行时间，这个进程就在颠簸</p><h4 id="系统颠簸的原因"><a class="anchor" href="#系统颠簸的原因">#</a> 系统颠簸的原因</h4><p>颠簸导致严重的性能问题</p><p>当 CPU 使用率比较低的时候，CPU 调度程序就会增加多道程序的程度，就会引起更多的页错误。当继续增加多道程序的程度，就会出现系统颠簸，系统吞吐量陡降，页错误增加，有效内存访问时间增加。</p><p>局部置换算法（或优先置换算法）可以限制系统颠簸。但是即使没有颠簸，也会增加其有效访问时间。</p><p>工作集合策略研究一个进程实际使用多少帧，定义了进程执行的<strong>局部模型（locality model）</strong></p><p>局部模型说明当进程执行时，从一个局部移到另一个局部。局部是一个进程使用页的集合。一个程序通常由多个不同局部组成。</p><p>如果分配的帧数小于现有的局部大小，系统就会颠簸。</p><h4 id="工作集合模型"><a class="anchor" href="#工作集合模型">#</a> 工作集合模型</h4><p>working-set model，是基于局部性假设的。</p><p>最近引用的页集合称为<strong>工作集合 (working set)</strong></p><p>工作集合窗口 (working-set window)</p><ul><li>如果太小则不能包含整个局部</li><li>如果太大可能包含多个局部</li><li>如果为无穷大，那么就为进程执行所接触的所有页的集合</li></ul><p>总的帧需求量 = 每个进程工作集合的和</p><p>如果总需求大于可用帧的数量，那么有的进程就得不到足够的帧，系统就会出现颠簸。</p><p>工作集合策略：系统跟踪每个进程的工作集合，并为进程分配大于其工作集合的帧数。</p><ul><li>有空闲帧：启动另一进程</li><li>所有工作集合之和大于总的可用帧数：暂停一个进程</li></ul><p>防止了颠簸，并尽可能提高多道程序程序，优化了 CPU 使用率</p><p>困难：跟踪工作集合。</p><p>使用中断和引用位（历史位），判断是否在工作集合。</p><h4 id="页错误频率"><a class="anchor" href="#页错误频率">#</a> 页错误频率</h4><p>page-fault frequency, PFF</p><p>防止颠簸更为直接的方法。</p><p>通过页错误频率判断是否需要帧。</p><p>如果实际错误率低，那么就放弃一些帧</p><p>如果实际错误率高，那么就获得一些帧</p><h3 id="内存映射文件"><a class="anchor" href="#内存映射文件">#</a> 内存映射文件</h3><p>将文件 I/O 作为普通内存访问，称为文件的内存映射 (memory mapping)</p><p>开始的文件访问按普通的请求页面调度来进行，会产生页错误。</p><p>简化了文件访问和使用</p><p>允许多个进程将同一文件映射到各自的虚拟内存中，以允许<strong>数据共享</strong></p><h3 id="内核内存的分配"><a class="anchor" href="#内核内存的分配">#</a> 内核内存的分配</h3><p>内核内存分配通常是从空闲内存池中获取的，而不是从满足普通用户模式进程的内存链表中获取。</p><ul><li>内核需要为不同大小的数据结构分配内存</li><li>用户进程所分配的页不必要在连续的内存，而有的硬件需要</li></ul><h3 id="其他考虑"><a class="anchor" href="#其他考虑">#</a> 其他考虑</h3><h4 id="预调页"><a class="anchor" href="#预调页">#</a> 预调页</h4><p>prepaging</p><p>试图阻止大量的初始调页。</p><p>预调页成本应该小于处理相应页错误的成本</p><h4 id="页大小"><a class="anchor" href="#页大小">#</a> 页大小</h4><p>总的来说趋向大的页</p><p>内部碎片和局部性需要小页</p><p>表大小和 I/O 时间需要大页</p><h4 id="tlb-范围"><a class="anchor" href="#tlb-范围">#</a> TLB 范围</h4><p>TLB 命中率 hit ratio：通过 TLB 而不是页表进行的虚拟地址转换的百分比</p><p>增加 TLB 条数可以增加命中率</p><p>TLB 范围：通过 TLB 可以访问的内存量，等于 TLB 条数和页大小的积</p><p>可以通过增加页的大小或者提供多种页大小增加 TLB 范围</p><h4 id="反向页表-2"><a class="anchor" href="#反向页表-2">#</a> 反向页表</h4><p>可以降低为了跟踪虚拟地址到物理地址转换所需的物理内存的数量</p><h4 id="程序结构"><a class="anchor" href="#程序结构">#</a> 程序结构</h4><p>数据结构和程序结构的仔细选择可以增加局部性，避免过多的页错误</p><p>编译器和载入器对调页也有重要影响</p><h4 id="io-互锁"><a class="anchor" href="#io-互锁">#</a> I/O 互锁</h4><p>I/O Interlock</p><p>有时需要允许有些页在内存中被锁住（当需要对用户的内存进行 I/O 时）</p><p>解决方法：</p><ul><li>不对用户内存进行 I/O，在系统内存和 I/O 设备之间进行，会带来高开销</li><li>允许页锁在内存中，每个帧有一个锁住位</li></ul><h1 id="第四部分-存储管理"><a class="anchor" href="#第四部分-存储管理">#</a> 第四部分 存储管理</h1><h2 id="第-10-章-文件系统接口"><a class="anchor" href="#第-10-章-文件系统接口">#</a> 第 10 章 文件系统接口</h2><p>文件系统的组成：</p><ul><li>文件（存储相关数据）</li><li>目录结构（组织系统内的文件并体哦概念股有关文件的信息）</li></ul><h3 id="文件概念"><a class="anchor" href="#文件概念">#</a> 文件概念</h3><p>记录在外存上的相关信息具有名称的集合</p><p>连续的逻辑地址空间</p><p>类型：</p><ul><li>数据</li><li>程序</li></ul><p>文件结构：</p><ul><li>二进制</li><li>简单的记录结构<ul><li>线性</li><li>定长</li><li>可变长度</li></ul></li><li>复杂的结构<ul><li>格式化的文档</li><li>动态加载的文件</li></ul></li></ul><h4 id="文件属性"><a class="anchor" href="#文件属性">#</a> 文件属性</h4><p>通常包括属性：</p><ul><li>名称 Name</li><li>标识符 Identifier</li><li>类型 Type</li><li>位置 Location</li><li>大小 Size</li><li>保护 Protection</li><li>时间、日期和用户标识 Time, data and user identification</li></ul><p>文件信息保存在目录结构中。</p><h4 id="文件操作"><a class="anchor" href="#文件操作">#</a> 文件操作</h4><ul><li>创建文件 Create：<ul><li>为文件在文件系统中找到空间</li><li>在目录中创建一个条目</li></ul></li><li>写文件 Write</li><li>读文件 Read</li><li>在文件内重定位 Reposition within file</li><li>删除文件 Delete</li><li>截短文件 Truncate：<ul><li>删除内容但保留属性</li></ul></li></ul><p>系统维护一个包含所有打开文件的信息表 (打开文件表， open-file table)</p><p>打开文件的信息：</p><ul><li>文件指针</li><li>文件打开计数器</li><li>文件磁盘位置</li><li>访问权限</li></ul><p>文件还有加锁机制</p><ul><li>强制 Mandatory：系统阻止其他进程访问已加锁的文件</li><li>建议 Advisory：在访问文件之前需要取得锁</li></ul><h4 id="文件类型"><a class="anchor" href="#文件类型">#</a> 文件类型</h4><p>UNIX 系统采用幻数 (magic number)(保存在文件的开始部分) 大致表明文件类型。也可以根据扩展名。</p><h4 id="文件结构"><a class="anchor" href="#文件结构">#</a> 文件结构</h4><p>用于表示文件的内部结构</p><h4 id="内部文件结构"><a class="anchor" href="#内部文件结构">#</a> 内部文件结构</h4><p>一般会将若干个逻辑记录打包，再放入物理记录。</p><h3 id="访问方法"><a class="anchor" href="#访问方法">#</a> 访问方法</h3><h4 id="顺序访问"><a class="anchor" href="#顺序访问">#</a> 顺序访问</h4><p>文件信息按顺序，一个记录接着一个记录低加以处理</p><p>适用于顺序访问设备和随机访问设备</p><h4 id="直接访问"><a class="anchor" href="#直接访问">#</a> 直接访问</h4><p>文件由固定长度的逻辑记录组成，以允许程序按任意顺序进行快速读写。常用于访问大量信息（数据库）</p><h4 id="其他访问方式"><a class="anchor" href="#其他访问方式">#</a> 其他访问方式</h4><p>通常涉及创建文件索引，索引包括各块的指针。</p><h3 id="目录结构"><a class="anchor" href="#目录结构">#</a> 目录结构</h3><h4 id="存储结构-2"><a class="anchor" href="#存储结构-2">#</a> 存储结构</h4><p>磁盘可以整体地用于一个文件系统，也可以每一个分区创建一个文件系统，也可以多个磁盘创建一个分区。</p><p>一个分区分为目录和文件</p><h4 id="目录概述"><a class="anchor" href="#目录概述">#</a> 目录概述</h4><p>目录可以看作符号表，他能将文件名称转换成目录条目。</p><p>目录的操作：</p><ul><li>搜索文件</li><li>创建文件</li><li>删除文件</li><li>遍历目录</li><li>重命名文件</li><li>跟踪文件系统</li></ul><p>目标:</p><ul><li>效率： 快速定位文件</li><li>命名：<ul><li>两个用户对于不同的文件可以有相同的名字</li><li>相同的文件可以有不同的名字</li></ul></li><li>分组</li><li>多用户系统的共享</li></ul><h4 id="单层结构目录"><a class="anchor" href="#单层结构目录">#</a> 单层结构目录</h4><p>最简单的目录结构，所有文件都包含在同一目录，便于理解和支持。</p><h4 id="双重结构目录"><a class="anchor" href="#双重结构目录">#</a> 双重结构目录</h4><p>主文件目录 (master file directory, MFD)</p><p>为每个用户创建独立目录（user file directory, UFD）</p><p>对用户进行了隔离，解决了名称冲突的问题</p><p>缺点：用户需要某个任务上进行合作和访问其他文件的要求，还有系统文件的共享</p><p>解决方法：修改搜索步骤，设置一个搜索路径（包括系统文件）</p><h4 id="树状结构目录"><a class="anchor" href="#树状结构目录">#</a> 树状结构目录</h4><p>将目录结构扩展为任意高度的树</p><p>目录包括一组文件和子目录</p><p>路径名：绝对路径和相对路径</p><ul><li>绝对路径名：从根开始并给出路径上的目录名直到所指定的文件</li><li>当前目录名：从当前目录开始定义路径</li></ul><p>用户初始当前目录在用户进程开始或者用户登陆时指定</p><p>允许用户自定义自己的子目录结构，按一定结构组织文件</p><p>还能访问其他用户的路径</p><h4 id="无环图目录"><a class="anchor" href="#无环图目录">#</a> 无环图目录</h4><p>树状结构禁止共享文件和目录，无环图 (acyclic graph) 允许共享子目录和文件。</p><p>无环图是树状结构的扩展</p><p>实现共享文件和目录的方法：</p><ul><li>创建一个称为链接的新目录条目（特殊的类型或目录条目格式），实际上是另一文件或目录的指针。</li><li>重复所有共享文件的信息，修改文件时需要维护一致性。</li></ul><p>存在的问题：</p><ul><li>一个文件可以有多个绝对路径名。对于遍历操作需要注意重复。</li><li>删除会留下悬挂指针指向不再存在的文件</li></ul><p>对于链接，一般的做法为，如果原文件被删除，其符号链接并不删除。</p><p>删除的另一方法：保留文件直到删除其所有引用为止。需要为每个文件保留一个引用列表或计数。</p><h4 id="通用图目录"><a class="anchor" href="#通用图目录">#</a> 通用图目录</h4><p>当树状结构目录增加链接时，树状结构就会被破坏，产生简单的图结构。（可能存在环）</p><p>问题：</p><ul><li>遍历可能会死循环或者多重遍历</li><li>无法确定什么时候可以删除</li></ul><p>避免多次搜索同一部分的解决方法：</p><ul><li>限制搜索时访问目录次数</li><li>遍历目录时避开链接</li></ul><p>当存在自我引用时候，引用计数不可能为 0，因此需要垃圾收集，但是极为费时。</p><p><strong>垃圾收集方案</strong>：遍历整个文件系统，并标记所有可访问的空间，第二次遍历将没有标记的收集到空闲空间链表上。（标记方法可以确保只进行一次遍历）</p><p>如何使得无环：</p><ul><li>只允许链接到文件</li><li>垃圾回收</li><li>新建链接得时候检测环</li></ul><h3 id="文件系统挂载"><a class="anchor" href="#文件系统挂载">#</a> 文件系统挂载</h3><p>文件系统在被系统上的进程使用之前必须挂载 (mount)</p><p>挂载步骤：</p><ul><li>确定<strong>挂载点</strong> (mount point)， 通常为空目录</li><li>验证设备上是否存在有效文件系统（通过驱动读取目录验证）</li></ul><p>不同系统的结果：</p><ul><li>不允许在包含文件目录下挂载<ul><li>或使已存在的文件不可见，直到文件系统被卸载</li></ul></li><li>允许多次重复挂载<ul><li>或只允许挂载一次</li></ul></li></ul><h3 id="文件共享"><a class="anchor" href="#文件共享">#</a> 文件共享</h3><h4 id="多用户"><a class="anchor" href="#多用户">#</a> 多用户</h4><p>绝大多数多用户系统采用文件（或目录）拥有者（或用户）和组的概念。</p><p>拥有着：目录最高控制权的用户，可以改变属性和授权访问。</p><p>组：对文件拥有相同权限的用户子集。</p><p>拥有者 ID 和组 ID 于文件属性一起保存</p><h4 id="远程文件系统"><a class="anchor" href="#远程文件系统">#</a> 远程文件系统</h4><p>远程文件共享方式：</p><ul><li>通过程序（如 ftp）实现文件的人工传输<ul><li>匿名或验证访问</li></ul></li><li>分布式文件系统 (DFS)，远程目录可本机直接访问<ul><li>紧密结合</li></ul></li><li>万维网，使用浏览器访问<ul><li>几乎总是匿名</li></ul></li></ul><p><strong>客户机 - 服务器模型</strong></p><ul><li>服务器可以服务多个客户端</li><li>验证一般不太安全，可能会被欺骗</li><li>UNIX 的网络文件系统 NFS</li><li>Windows 的标准协议 CIFS</li></ul><p><strong>分布式信息系统</strong></p><p>也称分布式命名服务 distributed naming services</p><p>提供用于远程计算所需信息的同一访问，域名系统 (DNS) 为整个 Internet 提供了主机名称到网络地址的转换</p><p><strong>故障模式</strong></p><p>恢复故障需要在客户机和服务器之间一定的状态信息</p><p>无状态的 NFS 在每个请求包含了所有信息，恢复很简单但是不安全</p><h4 id="一致性语义"><a class="anchor" href="#一致性语义">#</a> 一致性语义</h4><p>consistency semantics</p><p>是评估文件系统对文件共享支持的一个重要准则</p><p>规定了一个用户所修改的数据何时对另一用户可见。</p><p>在 <code>open()</code> 和 <code>close()</code> 操作之间的一系列访问称为文件会话</p><p>一致性语义：</p><ul><li>UNIX 语义<ul><li>一个文件于单个物理映射相关联，是互斥资源</li><li>一个用户对文件的修改可以理解被其他用户看到</li><li>允许多用户共享文件指针</li></ul></li><li>会话语义（AFS）<ul><li>一个文件同时可与多个物理映射暂时相关联，允许并发读写</li><li>一个用户对文件的写不能立即被其他用户看到</li><li>一旦文件关系，对其的修改只能被以后打开的会话看到</li></ul></li><li>不可修改共享文件语义<ul><li>只能读</li></ul></li></ul><h3 id="保护-2"><a class="anchor" href="#保护-2">#</a> 保护</h3><p>使信息不受物理损坏（可靠性）和非法访问（保护）</p><p>可靠性由文件备份提供。</p><p>保护有多种方法。</p><h4 id="访问类型"><a class="anchor" href="#访问类型">#</a> 访问类型</h4><p>如果系统允许对其他用户文件进行访问，那么就需要文件保护</p><p>控制访问 controlled access</p><p>控制的操作类型:</p><ul><li>读</li><li>写</li><li>执行</li><li>添加</li><li>删除</li><li>列表清单</li></ul><h4 id="访问控制"><a class="anchor" href="#访问控制">#</a> 访问控制</h4><p>解决保护问题的常用方法：根据用户身份进行控制</p><p>实现基于身份访问的普通方法：增加一个访问控制列表（access-control list，ACL），给定每个用户名及其允许的访问类型</p><p>缺点：</p><ul><li>当不知道用户列表时，创建列表会比较麻烦</li><li>目录条目必须可变大小，不利于空间管理</li></ul><p>改进：</p><p>为拥有着、组、其他创建访问列表</p><p>三种访问模式：</p><ul><li>Read</li><li>Write</li><li>Execute</li></ul><p>三种用户类型：</p><ul><li>Owner access</li><li>Group access</li><li>Public access</li></ul><h4 id="其他保护方式"><a class="anchor" href="#其他保护方式">#</a> 其他保护方式</h4><p>为每个文件加上密码</p><h2 id="第-11-章-文件系统的实现"><a class="anchor" href="#第-11-章-文件系统的实现">#</a> 第 11 章 文件系统的实现</h2><h3 id="文件系统结构"><a class="anchor" href="#文件系统结构">#</a> 文件系统结构</h3><p>磁盘的特点：</p><ul><li>可以原地重写</li><li>可以直接访问磁盘上任意一块信息</li></ul><p>文件系统的设计问题：</p><ul><li>如何定义文件系统对用户的接口</li><li>创建数据结构和算法将逻辑文件系统映射到物理外存设备</li></ul><p>分层设计的文件系统：</p><ul><li>应用程序</li><li>逻辑文件系统<ul><li>管理元数据（文件系统的所有结构数据，不包括实际数据）</li><li>根据符号文件名管理目录结构，提供文件组织模块信息</li><li>通过<strong>文件控制块</strong>（file control block，FCB，包括文件的信息）维护文件结构</li><li>负责保护和安全</li></ul></li><li>文件组织系统<ul><li>将逻辑块（簇）地址转换成物理块地址</li><li><strong>空闲空间管理器</strong>，跟踪未分配的块并根据要求提供文件组织模块</li></ul></li><li>基本文件系统<ul><li>向驱动发送一般命令，对磁盘上<strong>物理块</strong>进行读写</li></ul></li><li>I/O 控制<ul><li>最底层</li><li>由设备驱动程序（翻译器、控制硬件控制器）和中断处理程序组成</li><li>实现内存与磁盘之间信息传输</li></ul></li><li>设备</li></ul><h3 id="文件系统实现"><a class="anchor" href="#文件系统实现">#</a> 文件系统实现</h3><h4 id="概述-2"><a class="anchor" href="#概述-2">#</a> 概述</h4><p>引导控制块 (boot control block)：</p><ul><li>包括系统从该卷引导操作系统所需要的信息</li><li>UFS 中的<strong>引导块 (boot block)</strong></li><li>NTFS 中的<strong>分区引导扇区 (partition boot sector)</strong></li></ul><p>卷控制块 (volume control block)</p><ul><li>包括卷（或分区）的详细信息</li><li>UFS 中的<strong>超级块 (superblock)</strong></li><li>NTFS 中的<strong>主控文件表 (Master File Table)</strong></li></ul><p>目录结构</p><ul><li>组织文件</li><li>UFS 包含文件名、相关索引节点 (index) 号</li><li>NTFS 存储在 MFT 中</li></ul><p>FCB</p><ul><li>文件的详细信息</li><li>UFS 中的索引节点 (inode)</li><li>NTFS 在 MFT 中</li></ul><p>内存内信息</p><ul><li>管理文件系统、通过缓冲提高性能</li><li>包括<ul><li>安装表：所有安装卷的信息</li><li>目录结构缓存，保存近来访问的目录信息（或指针）</li><li>系统范围内打开文件表 (system-wide open-file table)：每个打开文件 FCB 副本和其他信息</li><li>单个进程的打开文件表 (pre-process open-file table)：指向系统范围打开文件表的指针</li></ul></li></ul><p>访问打开文件表的索引：</p><ul><li>UNIX 的<strong>文件描述符 (file descriptor)</strong></li><li>Windows 的<strong>文件句柄 (file handle)</strong></li></ul><p>大多数系统在内存保留了打开文件的所有信息（除了实际数据块）</p><h4 id="分区与安装"><a class="anchor" href="#分区与安装">#</a> 分区与安装</h4><p>分区：</p><ul><li>raw，生的，原始的，没有文件系统</li><li>cooked，熟的，含有文件系统</li></ul><p>生分区（raw disk）：</p><ul><li>UNIX 交换空间</li><li>数据库</li><li>RAID 磁盘系统</li></ul><p><strong>根分区</strong> (root partition): 包括操作系统内核或其他系统文件，引导时装入内存</p><p>Windows 将卷装入到独立名称空间中，用字母和冒号表示</p><p>UNIX 将文件系统装在任何目录上</p><h4 id="虚拟文件系统"><a class="anchor" href="#虚拟文件系统">#</a> 虚拟文件系统</h4><p>Virtual File System， VFS</p><p>文件系统实现包括三个主要层次：</p><ul><li>第一层为文件系统接口</li><li>第二层为虚拟文件系统 (VFS) 层<ul><li>定义一个清晰的<strong>接口</strong>，将文件系统的通用操作和具体实现分开</li><li>提供在网络上唯一标识一个文件的机制</li><li>VFS 可以区分本地 / 远程、不同文件系统类型的不同本地文件</li></ul></li><li>第三层是不同的文件系统</li></ul><p>Linux 中 VFS 的主要对象类型:</p><ul><li>索引节点对象 (inode object)，表示一个单独的文件</li><li>文件对象 (file object)，表示一个打开的文件</li><li>超级块对象 (superblock object)，表示整个文件系统</li><li>目录条目对象 (dentary object)，表示一个单独的目录条目</li></ul><h3 id="目录实现"><a class="anchor" href="#目录实现">#</a> 目录实现</h3><h4 id="线性列表"><a class="anchor" href="#线性列表">#</a> 线性列表</h4><p>使用存储文件名和数据块指针的线性列表</p><p>编程简单</p><p>缺点：</p><ul><li>运行费时</li><li>查找文件需要线性搜索</li></ul><h4 id="哈希表"><a class="anchor" href="#哈希表">#</a> 哈希表</h4><p>根据文件名得到一个值，并返回一个指向线性列表中元素的指针</p><p>可以使用 chained-overflow 哈希表</p><h3 id="分配方式"><a class="anchor" href="#分配方式">#</a> 分配方式</h3><h4 id="连续分配"><a class="anchor" href="#连续分配">#</a> 连续分配</h4><p>Contiguous Allocation</p><p>每个文件在磁盘上占有一组连续的块</p><p>优点：</p><ul><li>简单，只需要开始位置和长度</li><li>支持随机访问</li></ul><p>缺点：</p><ul><li>浪费空间</li><li>文件不能增长（使用扩展，但是存在外部和内部碎片问题）</li><li>难以为新文件找到空间（使用动态存储分配）</li><li>存在外部碎片（可以通过合并解决，需要停机操作）</li></ul><h4 id="链接分配"><a class="anchor" href="#链接分配">#</a> 链接分配</h4><p>解决了连续分配的所有问题。磁盘块分布在磁盘的任何地方。</p><p>目录包括文件第一块指针和最后一块的指针</p><p>缺点：</p><ul><li>只能有效地用于文件的顺序访问，<strong>不能有效支持文件的直接访问</strong></li><li>指针需要空间</li><li>可靠性（可能导致错误指针）</li><li>文件可能分散到很多柱面，寻道时间、次数增加</li></ul><p>解决方法：</p><ul><li>多个块组成簇，按簇分配而不是按块分配（增加了内部碎片）</li></ul><p>变种：FAT，文件分配表</p><p>每个卷开始用于存储该 FAT，采用缓存，改善了随机访问时间。</p><h4 id="索引分配"><a class="anchor" href="#索引分配">#</a> 索引分配</h4><p>通过把所有指针放在一起，使用索引块（磁盘块地址的数组）</p><p><strong>支持直接访问</strong>，没有外部碎片。</p><p>缺点：浪费空间（索引块需要占用一块）</p><p>索引块大小问题：</p><ul><li>链接方案 ：将多个索引块链接起来</li><li>多层索引：用第一层索引块指向一组第二层索引块。</li><li>组合方案：UFS 中，前 12 个指向直接块，最后三个指向间接块<ul><li>第一个为一级间接块，为索引块，包含数据块的地址</li><li>第二个为二级间接块，包括一级索引块的地址</li><li>第三个为三级间接块</li><li>如果块大小为 4K，那么不超过 48K 的文件就可以直接访问</li></ul></li></ul><p>Linux 下目录结构</p><p>基本文件目录 (BFD), <code>i</code> 节点表，存储地址</p><p>主目录 (MFD) 存储文件名和对应 BFD 中的 ID</p><p>SFD 也是一样</p><p>优点：</p><ul><li>便于共享</li><li>检索速度快，减少了访问磁盘的次数</li></ul><p>Linux 文件卷存储结构</p><ul><li>引导块 - 超级块（文件资源表， 专用块） - 索引节点块（<strong>基本文件目录，BFD</strong>） - 数据块</li></ul><h3 id="空闲空间管理"><a class="anchor" href="#空闲空间管理">#</a> 空闲空间管理</h3><p>为了记录空闲磁盘空间，系统需要维护一个<strong>空闲空间链表 (free-space list)</strong></p><p>它记录了所有空闲磁盘空间（未分配给文件或目录的空间）</p><h4 id="位向量"><a class="anchor" href="#位向量">#</a> 位向量</h4><p>空闲空间表通常实现为<strong>位图</strong>或<strong>位向量</strong></p><p>优点：</p><ul><li>查找第一个空闲块和连续空闲块简单高效</li></ul><p>需要位向量存在内存中才有高效率，因此需要额外的空间</p><p>多次分配和回收可以集中起来写盘</p><h4 id="链表"><a class="anchor" href="#链表">#</a> 链表</h4><p>将所有空闲磁盘块用链表连接起来，将第一空闲块支持保存在磁盘特殊位置和内存中。</p><p>缺点：遍历整个表时，效率不高，需要大量 I/O</p><p>每一次分配和回收都需要 I/O</p><h4 id="组"><a class="anchor" href="#组">#</a> 组</h4><p>将 n 个空闲块地址存在第一个空闲块中，大量空闲块地址可以很快找到</p><p><strong>成组链接法</strong>：</p><p>每一组的第一个块存储上一个组所有块的块号</p><p>一个超级块存储最后一个组的所有块的块号。</p><p>分配：用一个堆栈保存一组的所有块号，从栈顶开始分配，直到最后一个块（存储着下一组的块号），再次读磁盘，把这个块存储的块号填充到栈中。</p><p>回收：入栈、当栈满了就写到一个磁盘块中，然后再压仅栈里</p><p>可以做到一个组才读一次磁盘。</p><h4 id="计数"><a class="anchor" href="#计数">#</a> 计数</h4><p>空闲空间表包括每个条目的磁盘地址和数量</p><h3 id="效率与性能"><a class="anchor" href="#效率与性能">#</a> 效率与性能</h3><h4 id="效率"><a class="anchor" href="#效率">#</a> 效率</h4><p>磁盘空间的有效使用主要取决于所使用的<strong>磁盘分配</strong>和<strong>目录管理算法</strong>。</p><h4 id="性能"><a class="anchor" href="#性能">#</a> 性能</h4><ul><li>缓存<ul><li>板载高速缓存：可以同时存储整个磁道，使用缓存存储经常使用的数据块</li><li>页面缓存：使用虚拟内存技术，存储文件数据</li></ul></li><li>优化顺序访问<ul><li>马上释放 free-behind：在请求下一页的时候，马上从缓存删除上一页</li><li>预读 read-ahead：所请求的页和之后一些页可一起读入并缓存</li></ul></li></ul><h3 id="恢复"><a class="anchor" href="#恢复">#</a> 恢复</h3><h4 id="一致性检查"><a class="anchor" href="#一致性检查">#</a> 一致性检查</h4><p>将目录结构数据与磁盘数据块相比较，并试图纠正所发现的不一致</p><h4 id="备份和恢复"><a class="anchor" href="#备份和恢复">#</a> 备份和恢复</h4><p>利用系统程序将磁盘数据备份到另一存储设备</p><p>一开始使用 完全备份 (full backup)</p><p>然后使用 增量备份 (incremental backup)</p><h3 id="基于日志结构的文件系统"><a class="anchor" href="#基于日志结构的文件系统">#</a> 基于日志结构的文件系统</h3><p>所有元数据都按顺序写到日志上。</p><p>执行一个特殊任务的一组操作称为<strong>事务</strong> (transaction)。</p><p>使用环形缓冲，写到空间末尾的时候，从头开始写</p><p>当系统崩溃时候，可以利用日志进行恢复</p><h3 id="nfs"><a class="anchor" href="#nfs">#</a> NFS</h3><p>Network File System</p><p>用于通过局域网访问远程文件的软件系统的实现和规范</p><p>将一组互连工作站作为具有独立文件系统的机器组合</p><p>在访问远程目录之前需要先安装 (mount)</p><p>NFS 设计目标之一：允许不同机器、操作系统和网络结构的异构环境中工作。</p><p>在两种独立实现接口之间采用基于外部数据表示 (XDR) 的 RPC</p><h4 id="安装协议"><a class="anchor" href="#安装协议">#</a> 安装协议</h4><p>mount protocol</p><p>在客户机和服务器之间建立初始逻辑连接</p><p>服务器维护一个输出列表 (export list)，列出哪些本地文件系统允许输出安装，并允许安装他们的机器名称</p><h4 id="nfs-协议"><a class="anchor" href="#nfs-协议">#</a> NFS 协议</h4><ul><li>搜索目录内文件</li><li>读一组目录条目</li><li>操作链接和目录</li><li>访问文件属性</li><li>读和写文件</li></ul><p>NFS 服务器是无状态的</p><h4 id="路径名转换"><a class="anchor" href="#路径名转换">#</a> 路径名转换</h4><p>把路径名解析为独立的目录条目或组成部分</p><h4 id="远程操作"><a class="anchor" href="#远程操作">#</a> 远程操作</h4><p>除了 <code>open</code> 和 <code>cloase</code> ，在普通 UNIX 文件操作系统调用和 NFS 协议 RPC 之间，有着一对一的对应关系</p><p>NFS 实际采用了缓冲和缓存技术以提高性能</p><ul><li>文件属性（索引节点信息）缓存</li><li>文件块缓存</li></ul><h2 id="第-12-章-大容量存储器的结构"><a class="anchor" href="#第-12-章-大容量存储器的结构">#</a> 第 12 章 大容量存储器的结构</h2><h3 id="大容量存储器结构简介"><a class="anchor" href="#大容量存储器结构简介">#</a> 大容量存储器结构简介</h3><h4 id="磁盘"><a class="anchor" href="#磁盘">#</a> 磁盘</h4><p>磁盘为现代计算机系统提供了大容量的内存</p><p>读写头 “飞行” 于每个磁盘片的表面之上。</p><p>磁头与<strong>磁臂</strong> (disk arm) 相连，磁臂能将所有磁头作为一个整体一起移动。</p><p>磁盘片的表面被逻辑划分为圆形<strong>磁道</strong> (track)</p><p>磁道进一步划分为<strong>扇区</strong> (sector)</p><p>同一磁臂位置的磁道集合形成了<strong>柱面</strong> (cylinder)</p><p>每个磁盘驱动器有数千个同心柱面，每个磁道有数百个扇区</p><p><strong>传输速率</strong> (transfer rate)：驱动器和计算机之间的数据传输速率</p><p>** 定位时间 (positioning time)/ 随机访问时间 (random access time)** 由两部分组成：</p><ul><li><strong>寻道时间</strong> (seek time)：移动磁臂到说要的柱面所需的时间（主要）</li><li>** 旋转等待时间 (**rotational latency)：等待所要的扇区旋转到磁臂下所需时间</li></ul><p><strong>磁头碰撞</strong> (head crash) 会损坏磁盘表面，不能修复。</p><p>磁盘驱动器通过一组 I/O 总线 (I/O bus) 和计算机相连，总线包括：</p><ul><li>EIDE: enhanced integrated drive electronics</li><li>ATA: advanced technology attachment</li><li>串行 ATA: serial ATA, SATA</li><li>USB: universal serial bus</li><li>FC: fiber channel</li><li>SCSI 总线</li></ul><p>控制器 (controller) 处理总线上的输出传输：</p><ul><li>主机控制器 (host controller) 是计算机上位于总线末端的控制器</li><li>磁盘控制器 (disk controller) 是位于磁盘驱动器内的控制器</li></ul><h4 id="磁带"><a class="anchor" href="#磁带">#</a> 磁带</h4><p>太慢</p><p>磁带绕在轴上，向前转后向后转并经过读写头。</p><h3 id="磁盘结构"><a class="anchor" href="#磁盘结构">#</a> 磁盘结构</h3><p>现代磁盘驱动器可以看作一个一位的<strong>逻辑块</strong>的数组，逻辑块是最小的传输单位。</p><p>对使用常量线性速度 (constant linear velocity, CLV) 的介质，每个磁道的位密度是相同的</p><p>驱动器会增加速度保持磁头读写数据速率恒定</p><p>或者</p><p>使用恒定圆角速度 (constant angular velocity, CAV), 内磁道到外磁道的位密度要不断降低</p><h3 id="磁盘附属"><a class="anchor" href="#磁盘附属">#</a> 磁盘附属</h3><p>访问磁盘存储的方式：</p><ul><li>I/O 端口 (或主机附属存储 host-attached storage, HAS)</li><li>分布式文件系统的远程主机 (网络附属存储 network-attached storage,NAS)</li></ul><h4 id="主机附属存储"><a class="anchor" href="#主机附属存储">#</a> 主机附属存储</h4><p>通过本地 I/O 访问存储</p><p>复杂的 I/O 结构：</p><ul><li>SCSI<ul><li>一根总线支持 16 个设备</li><li>包括主机的一个控制卡 (SCSI 引导器)</li><li>15 个存储设备 (SCSI 目标)</li><li>每个 SCSI 目标有访问 8 个逻辑单元的能力</li></ul></li><li>FC<ul><li>高速串行结构</li><li>存储区域网络 (SAN) 的基础</li><li>裁定循环 (FC-AL)：可以访问 126 个设备</li></ul></li></ul><h4 id="网络附属存储"><a class="anchor" href="#网络附属存储">#</a> 网络附属存储</h4><p>NAS 是数据网络中远程访问的专用存储系统</p><p>缺点：存储 I/O 操作需要使用数据网络的带宽，增加了网络通讯延迟</p><h4 id="存储区域网络"><a class="anchor" href="#存储区域网络">#</a> 存储区域网络</h4><p>storage area network，SAN</p><p>是服务器与存储单元之间的私有网络</p><p>优势：灵活性</p><h3 id="磁盘调度"><a class="anchor" href="#磁盘调度">#</a> 磁盘调度</h3><p>磁盘带宽：所传递的总的字节数除以从服务请求开始到最后传递结束的时间</p><h4 id="fcfs-调度"><a class="anchor" href="#fcfs-调度">#</a> FCFS 调度</h4><p>先来先服务算法</p><p>特定：公平</p><h4 id="sstf-调度"><a class="anchor" href="#sstf-调度">#</a> SSTF 调度</h4><p>最短寻到时间优先算法 shortest-seek-time-first</p><p>选择距当前磁头位置最短寻道时间的请求来处理</p><p>基本上是一种最短作业优先 (SJF) 调度，可能导致一些请求得不到服务，而且不是最优的</p><h4 id="scan-调度"><a class="anchor" href="#scan-调度">#</a> SCAN 调度</h4><p>磁臂从磁盘的一端向另一端移动，同时当磁头移过每个柱面时，处理位于该柱面上的服务请求。当到达另一端时，磁头改变移动方向，处理继续</p><p>有时称为电梯算法 (elevator algorithm)</p><h4 id="c-scan-调度"><a class="anchor" href="#c-scan-调度">#</a> C-SCAN 调度</h4><p>SCAN 的变种，提供更为均匀的等待时间</p><p>当磁头移到另一端的时候，立刻返回到磁盘开始，返回时候不处理请求</p><h4 id="look-调度"><a class="anchor" href="#look-调度">#</a> LOOK 调度</h4><p>类似于 SCAN，但是磁头只移动到一个方向的最远请求</p><p>C-LOOK 返回也是只是返回到最远，不是 0</p><h4 id="磁盘调度算法的选择"><a class="anchor" href="#磁盘调度算法的选择">#</a> 磁盘调度算法的选择</h4><p>SSTF: 普通而常见， 性能比 FCFS 好</p><p>SCAN 和 C-SCAN 对于磁盘负荷较大的系统会执行得更好，不可能产生饿死</p><p>性能主要依赖于请求的数量和类型。</p><p>磁盘服务请求很大程度上受文件分配方法所影响，连续分配会产生相近的请求，而链接或索引文件会产生大量的磁头移动</p><p>目录和索引页也很重要</p><h3 id="磁盘管理"><a class="anchor" href="#磁盘管理">#</a> 磁盘管理</h3><h4 id="磁盘格式化"><a class="anchor" href="#磁盘格式化">#</a> 磁盘格式化</h4><p>低级格式化：为磁盘每个扇区采用特别的数据结构</p><p>逻辑格式化：创建文件系统</p><h4 id="引导块"><a class="anchor" href="#引导块">#</a> 引导块</h4><p>自举程序保存正在磁盘的启动块中，位于磁盘的固定位置</p><h4 id="坏块"><a class="anchor" href="#坏块">#</a> 坏块</h4><p>磁盘控制器使用备用块逻辑低替换坏块，称为扇区备用 (sector sparing) 或转寄 (forwarding)</p><p>每个柱面都留有少量的备用块，还有备用柱面，防止系统的磁盘调度算法无效</p><p>还能采用扇区滑动 (sector slipping) 来替换坏扇区，所有扇区向某个方向偏移</p><h3 id="交换空间管理"><a class="anchor" href="#交换空间管理">#</a> 交换空间管理</h3><p>交换空间为虚拟内存提供最佳吞吐量</p><h4 id="交换空间的使用"><a class="anchor" href="#交换空间的使用">#</a> 交换空间的使用</h4><ul><li>可以保存整个进程映像</li><li>可以保存内存中的页</li></ul><h4 id="交换空间的位置"><a class="anchor" href="#交换空间的位置">#</a> 交换空间的位置</h4><ul><li>普通文件系统<ul><li>简单，但是效率低</li><li>遍历目录需要过多磁盘访问（可以缓存在物理内存中）</li></ul></li><li>一个独立的生磁盘分区上</li></ul><h3 id="raid-结构"><a class="anchor" href="#raid-结构">#</a> RAID 结构</h3><h4 id="通过冗余改善可靠性"><a class="anchor" href="#通过冗余改善可靠性">#</a> 通过冗余改善可靠性</h4><p>镜像 (mirroring) 是最为简单和昂贵的引入冗余的方法：复制每个磁盘</p><h4 id="通过并行处理改善性能"><a class="anchor" href="#通过并行处理改善性能">#</a> 通过并行处理改善性能</h4><p>数据分散：</p><ul><li>位级分散：在多个磁盘上分散每个字节的各个位，<ul><li>每次范围可以同时读 8 倍的数据</li><li>支持数量为 8 的倍数或者能除以 8 的数量的磁盘</li></ul></li><li>块级分散：一个文件的块分散在多个磁盘</li></ul><p>通过负荷平衡，增加了多个小访问的吞吐量</p><p>降低了大访问的响应时间</p><h4 id="raid-级别"><a class="anchor" href="#raid-级别">#</a> RAID 级别</h4><table><thead><tr><th style="text-align:left">RAID 档次</th><th style="text-align:left">最少硬盘</th><th style="text-align:left">最大容错</th><th style="text-align:left">可用容量</th><th style="text-align:left">读取性能</th><th style="text-align:left">写入性能</th><th style="text-align:left">安全性</th><th style="text-align:left">目的</th><th style="text-align:left">应用产业</th></tr></thead><tbody><tr><td style="text-align:left">单一硬盘</td><td style="text-align:left">(引用)</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">无</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">JBOD</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">n</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">无（同 RAID 0）</td><td style="text-align:left">增加容量</td><td style="text-align:left">个人（暂时）存储备份</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">2</td><td style="text-align:left">0</td><td style="text-align:left">n</td><td style="text-align:left">n</td><td style="text-align:left">n</td><td style="text-align:left">一个硬盘异常，全部硬盘都会异常</td><td style="text-align:left">追求最大容量、速度</td><td style="text-align:left">视频剪接缓存用途</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">2</td><td style="text-align:left">n-1</td><td style="text-align:left">1</td><td style="text-align:left">n</td><td style="text-align:left">1</td><td style="text-align:left">最高，一个正常即可</td><td style="text-align:left">追求最大安全性</td><td style="text-align:left">个人、企业备份</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">3</td><td style="text-align:left">1</td><td style="text-align:left">n-1</td><td style="text-align:left">n-1</td><td style="text-align:left">n-1</td><td style="text-align:left">高</td><td style="text-align:left">追求最大容量、最小预算</td><td style="text-align:left">个人、企业备份</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">4</td><td style="text-align:left">2</td><td style="text-align:left">n-2</td><td style="text-align:left">n-2</td><td style="text-align:left">n-2</td><td style="text-align:left">安全性较 RAID 5 高</td><td style="text-align:left">同 RAID 5，但较安全</td><td style="text-align:left">个人、企业备份</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">4</td><td style="text-align:left">n/2</td><td style="text-align:left">n/2</td><td style="text-align:left">n/2</td><td style="text-align:left">n/2</td><td style="text-align:left">安全性高，但在同一个子组群中不能出现两颗毁损硬盘</td><td style="text-align:left">综合 RAID 0/1 优点，理论速度较快</td><td style="text-align:left">大型数据库、服务器</td></tr></tbody></table><ul><li>RAID0<ul><li>按块级别分散的磁盘阵列</li><li>没有冗余</li></ul></li><li>RAID1<ul><li>磁盘镜像</li></ul></li><li>RAID2<ul><li>内存方式的差错<strong>纠正</strong>代码结构</li><li>基于奇偶位的错误检测，系统每个字节都有一个相关的奇偶位。</li><li>4 个磁盘需要 3 个额外磁盘</li></ul></li><li>RAID3<ul><li>位交织奇偶结构</li><li>磁盘控制器可以检测一个扇区是否争取读取</li><li>如果一个扇区损坏，那么知道是哪个扇区，通过计算其他磁盘扇区相应位的奇偶值可以得出损坏位是 0 或 1</li><li>优点<ul><li>只需要一个奇偶磁盘</li><li>字节的读写分布在多个磁盘上，单个块的读和写是 RAID1 的 N 倍</li></ul></li><li>缺点<ul><li>计算和写奇偶开销导致写更慢</li><li>可以使用非易失性随机存储器 (NVRAM)，在计算奇偶时存储块，缓存从控制器到磁盘的数据</li></ul></li></ul></li><li>RAID4<ul><li>块交织奇偶结构</li><li>磁盘可以并行读，数据和奇偶也可以并行写</li><li>小于块大小的数据的写必须访问数据所在块，修改数据后写回，相应奇偶块也要更新，称为<strong>读 - 改 - 写</strong>，单个写需要 4 次磁盘访问：两次读入旧块，两次写入新块</li></ul></li><li>RAID5<ul><li>块交织分布奇偶结构</li><li>将数据奇偶分布在所有 N+1 块磁盘上，而不是单个磁盘上</li><li>每一块，一个磁盘存储奇偶，其他存储数据</li></ul></li><li>RAID6<ul><li>P+Q 冗余方案</li><li>保存额外的冗余信息防止多个磁盘出错</li><li>使用差错纠正码，如 Read-Solomon 码</li></ul></li><li>RAID0+1<ul><li>先分散再镜像</li></ul></li><li>RAID1+0<ul><li>先镜像再分散</li></ul></li></ul><h4 id="raid-级别的选择"><a class="anchor" href="#raid-级别的选择">#</a> RAID 级别的选择</h4><h4 id="扩展"><a class="anchor" href="#扩展">#</a> 扩展</h4><h4 id="raid-的问题"><a class="anchor" href="#raid-的问题">#</a> RAID 的问题</h4><h3 id="稳定存储实现"><a class="anchor" href="#稳定存储实现">#</a> 稳定存储实现</h3><h3 id="三级存储结构"><a class="anchor" href="#三级存储结构">#</a> 三级存储结构</h3><h4 id="三级存储设备"><a class="anchor" href="#三级存储设备">#</a> 三级存储设备</h4><h4 id="操作系统支持"><a class="anchor" href="#操作系统支持">#</a> 操作系统支持</h4><h4 id="性能-2"><a class="anchor" href="#性能-2">#</a> 性能</h4><h2 id="第-13-章-io-输入系统"><a class="anchor" href="#第-13-章-io-输入系统">#</a> 第 13 章 I/O 输入系统</h2><h3 id="概述-3"><a class="anchor" href="#概述-3">#</a> 概述</h3><h3 id="io-硬件"><a class="anchor" href="#io-硬件">#</a> I/O 硬件</h3><p>四种 I/O 方法：</p><ul><li>轮询</li><li>中断</li><li>DMA</li><li>通道</li></ul><h4 id="轮询"><a class="anchor" href="#轮询">#</a> 轮询</h4><h4 id="中断-2"><a class="anchor" href="#中断-2">#</a> 中断</h4><p>中断与当前代码没有关系，异常与当前代码有关系</p><p>CPU 在执行完每条指令之后，检测 IRL（中断请求线，Interrupt-request line），如果有来自控制器的中断请求信号，CPU 就保存当前状态并且跳转到内存固定位置的中断处理程序 (interrupt-controller)</p><p>中断处理程序判断中断原因，进行必要的处理，重新恢复状态，最后执行中断返回 (return from interrupt) 指令以便使 CPU 返回中断前的执行状态</p><p>过程:</p><ul><li>设备控制器通过 IRL 发送信号 raise 中断</li><li>CPUcatch 中断并 dispatch 到 IC 中</li><li>IC 通过处理设备请求来 clear 中断</li></ul><p>中断特征（由 IC 硬件提供）：</p><ul><li>在关键处理时， 可以延迟中断处理</li><li>更有效地分发中断到合适中断处理程序</li><li>多级中断，区分优先级</li></ul><p>优点：可以并行</p><p>绝大多数 CPU 有两个中断请求线：</p><ul><li>非屏蔽中断：处理如不可恢复内存错误等事件</li><li>可屏蔽中断：可以被设备控制器用于请求服务</li></ul><h4 id="直接内存访问"><a class="anchor" href="#直接内存访问">#</a> 直接内存访问</h4><p>DMA direct-memory access</p><p>当 DMA 控制器抓住内存总线时， CPU 会暂时不能访问主内存。称为<strong>周期挪用 (cycle steal)</strong></p><p>DVMA direct virtual-memory access 直接虚拟内存访问</p><p>可以直接实现两个内存映射设备之间的传输，无需 CPU 的干涉或使用主内存。</p><p>步骤:</p><ul><li>设备驱动器被告知传递磁盘数据到地址为 X 的缓冲区</li><li>设备驱动器告诉磁盘控制器从磁盘传递 C 个字节到地址为 X 的缓冲区</li><li>磁盘控制器初始化 DMA 传输</li><li>磁盘控制器向 DMS 控制器发送每个字节</li><li>DMA 控制器向缓冲器 X 传递字节，增加内存地址并减少 C 直到 C = 0</li><li>当 C = 0 时，DMS 中断 CPU， 通知传输完毕。</li></ul><h4 id="通道"><a class="anchor" href="#通道">#</a> 通道</h4><p>一般用于服务器</p><p>可以实现多个连续段直接传输</p><h3 id="io-应用接口"><a class="anchor" href="#io-应用接口">#</a> I/O 应用接口</h3><p>设备驱动程序层的作用：为 I/O 子系统隐藏设备控制器之间的差异。</p><ul><li>数据传输模式<ul><li>字符流设备： 按一个字节一个字节地传输，如 终端</li><li>块设备：以块单位进行传输， 如磁盘</li></ul></li><li>访问方法<ul><li>顺序设备：按固定顺序来传输数据， 如调制解调器</li><li>随机访问设备：让设备寻找到任意数据存储位置，如 CD-ROM</li></ul></li><li>传输调度<ul><li>同步：按一定响应时间来进行数据传输， 磁带</li><li>异步：无规则或不可预测的响应时间，键盘</li></ul></li><li>共享<ul><li>共享：可以被多个进程或线程并发使用，如键盘</li><li>专用：磁带</li></ul></li><li>设备速度<ul><li>延迟</li><li>寻道时间</li><li>传输速率</li><li>操作之间的延迟</li></ul></li><li>I/O 方向<ul><li>读写， 磁盘</li><li>只读， CD-ROM</li><li>只写，图像控制器</li></ul></li></ul><h4 id="块与字符设备"><a class="anchor" href="#块与字符设备">#</a> 块与字符设备</h4><h4 id="网络设备"><a class="anchor" href="#网络设备">#</a> 网络设备</h4><h4 id="阻塞和非阻塞-io"><a class="anchor" href="#阻塞和非阻塞-io">#</a> 阻塞和非阻塞 I/O</h4><p>阻塞 I/O：应用程序的执行被挂起，等到系统调用完成后，应用程序就移回运行队列，并在合适的时候继续执行，并能收到系统返回的值</p><p>非阻塞 I/O：不会中止程序，马上返回任何可用的数据（等于或少于所要求的，或者为 0）</p><p>异步：调用要求的传输会完整执行，返回完整的结果（将来的某个时间）。</p><h3 id="io-内核子系统"><a class="anchor" href="#io-内核子系统">#</a> I/O 内核子系统</h3><h4 id="io-调度"><a class="anchor" href="#io-调度">#</a> I/O 调度</h4><h4 id="缓冲-2"><a class="anchor" href="#缓冲-2">#</a> 缓冲</h4><p>用来保存两个设备之间或在设备和应用程序之间所传输数据的内存区域。</p><p>采用缓冲的理由：</p><ul><li>处理数据流的生产者与消费者之间的速度差异</li><li>协调传输数据大小不一致的设备</li><li>支持应用程序 I/O 的复制语义（保证要写入磁盘的数据是系统调用发生时候的版本）</li></ul><h4 id="高速缓存-2"><a class="anchor" href="#高速缓存-2">#</a> 高速缓存</h4><p>可以保留数据副本的高速存储器，访问要比原始数据访问高效</p><p>有时缓冲区也可以用作高速缓存</p><h4 id="假脱机与设备预留"><a class="anchor" href="#假脱机与设备预留">#</a> 假脱机与设备预留</h4><p>用来保存设备数据的缓冲区</p><h4 id="错误处理"><a class="anchor" href="#错误处理">#</a> 错误处理</h4><h4 id="io-保护"><a class="anchor" href="#io-保护">#</a> I/O 保护</h4><h4 id="内核数据结构"><a class="anchor" href="#内核数据结构">#</a> 内核数据结构</h4><h4 id="内核-io-子系统总结"><a class="anchor" href="#内核-io-子系统总结">#</a> 内核 I/O 子系统总结</h4><h3 id="把-io-操作转化为硬件"><a class="anchor" href="#把-io-操作转化为硬件">#</a> 把 I/O 操作转化为硬件</h3><h3 id="流"><a class="anchor" href="#流">#</a> 流</h3><h3 id="性能-3"><a class="anchor" href="#性能-3">#</a> 性能</h3><div class="tags"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="ic i-tag"></i> 操作系统</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-09-29 23:07:21" itemprop="dateModified" datetime="2021-09-29T23:07:21+08:00">2021-09-29</time> </span><span id="2021/09/29/期末/操作系统概念 笔记/" class="item leancloud_visitors" data-flag-title="操作系统概念 笔记" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="lzs 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="lzs 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>lzs <i class="ic i-at"><em>@</em></i>Sakura</li><li class="link"><strong>本文链接：</strong> <a href="https://zengshengli775.gitee.io/2021/09/29/%E6%9C%9F%E6%9C%AB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%20%E7%AC%94%E8%AE%B0/" title="操作系统概念 笔记">https://zengshengli775.gitee.io/2021/09/29/期末/操作系统概念 笔记/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/09/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="prev" data-background-image="http:&#x2F;&#x2F;www.dmoe.cc&#x2F;random.php?775070" title="C语言基础知识"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 编程基础</span><h3>C语言基础知识</h3></a></div><div class="item right"><a href="/2021/10/01/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" itemprop="url" rel="next" data-background-image="http:&#x2F;&#x2F;www.dmoe.cc&#x2F;random.php?263887" title="C++核心编程"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 编程基础</span><h3>C++核心编程</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%A6%82%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第一部分 概论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-1-%E7%AB%A0-%E5%AF%BC%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">第 1 章 导论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.1.</span> <span class="toc-text">计算机系统操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.1.2.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">I&#x2F;O 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.5.</span> <span class="toc-text">计算机系统体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.6.</span> <span class="toc-text">操作系统结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.7.</span> <span class="toc-text">操作系统操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E6%A8%A1%E5%BC%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">双重模式操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">定时器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.8.</span> <span class="toc-text">进程管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.9.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.10.</span> <span class="toc-text">存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.10.1.</span> <span class="toc-text">文件系统管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.10.2.</span> <span class="toc-text">大容量存储器管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.10.3.</span> <span class="toc-text">高速缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.10.4.</span> <span class="toc-text">I&#x2F;O 系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%AE%89%E5%85%A8"><span class="toc-number">1.1.11.</span> <span class="toc-text">保护和安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.12.</span> <span class="toc-text">分布式系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.13.</span> <span class="toc-text">专用系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.14.</span> <span class="toc-text">计算环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%AE%A1%E7%AE%97"><span class="toc-number">1.1.14.1.</span> <span class="toc-text">传统计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E6%9C%BA-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A1%E7%AE%97"><span class="toc-number">1.1.14.2.</span> <span class="toc-text">客户机 - 服务器计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%AD%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.1.14.3.</span> <span class="toc-text">对等计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-web-%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">1.1.14.4.</span> <span class="toc-text">基于 Web 的计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">第 2 章 操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">操作系统服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="toc-number">1.2.2.</span> <span class="toc-text">操作系统的用户界面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A%E7%A8%8B%E5%BA%8Fcommand-interpreters"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">命令解释程序 (Command Interpreters)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2graphical-user-interfaces"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">图形用户界面 (Graphical User Interfaces)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8system-calls"><span class="toc-number">1.2.3.</span> <span class="toc-text">系统调用 (System Calls)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">系统调用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">进程控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">设备管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%AE%AF"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">通讯</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.5.</span> <span class="toc-text">系统程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">操作系统设计和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">设计目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%BA%E5%88%B6mechanism%E5%92%8C%E7%AD%96%E7%95%A5policy"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">机制（mechanism）和策略（policy）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2"><span class="toc-number">1.2.7.</span> <span class="toc-text">操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">简单结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E6%96%B9%E6%B3%95-layered"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">分层方法 Layered</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8-microkernel"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">微内核 Microkernel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97-modules"><span class="toc-number">1.2.7.4.</span> <span class="toc-text">模块 Modules</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.2.7.5.</span> <span class="toc-text">虚拟机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%94%9F%E6%88%90"><span class="toc-number">1.2.8.</span> <span class="toc-text">系统生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8"><span class="toc-number">1.2.9.</span> <span class="toc-text">系统启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">过程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">第二部分 进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">第 3 章 - 进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8Bprocesses"><span class="toc-number">2.1.1.</span> <span class="toc-text">进程（Processes）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">进程控制块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">2.1.2.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">调度队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8Fscheduler"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">调度程序（Scheduler）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2context-switch"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">上下文切换（Context switch）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.3.</span> <span class="toc-text">进程操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">进程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#unix-%E4%B8%AD"><span class="toc-number">2.1.3.1.1.</span> <span class="toc-text">UNIX 中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#windows-%E4%B8%AD"><span class="toc-number">2.1.3.1.2.</span> <span class="toc-text">Windows 中</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">进程终止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.4.</span> <span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">共享内存系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1-2"><span class="toc-number">2.1.5.</span> <span class="toc-text">操作系统服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B3%BB%E7%BB%9F-ipc"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">消息传递系统 IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E5%90%8D"><span class="toc-number">2.1.5.1.1.</span> <span class="toc-text">命名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">2.1.5.1.2.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%86%B2"><span class="toc-number">2.1.5.1.3.</span> <span class="toc-text">缓冲</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E6%9C%BA-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.6.</span> <span class="toc-text">客户机 - 服务器系统通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#socket"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">Socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">远程过程调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">第 4 章 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">多对一模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">一对一模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">多对多模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">二级模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%BA%93"><span class="toc-number">2.2.3.</span> <span class="toc-text">线程库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.4.</span> <span class="toc-text">多线程问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-fork%E5%92%8C-exec"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">系统调用 fork () 和 exec ()：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%96%E6%B6%88-thread-cancellation"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">线程取消 Thread Cancellation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-signal-handling"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">信号处理 Signal Handling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.2.4.4.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE-thread-specific-data"><span class="toc-number">2.2.4.5.</span> <span class="toc-text">线程的特定数据 Thread Specific Data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E6%BF%80%E6%B4%BB"><span class="toc-number">2.2.4.6.</span> <span class="toc-text">调度程序激活</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-5-%E7%AB%A0-cpu-%E8%B0%83%E5%BA%A6"><span class="toc-number">2.3.</span> <span class="toc-text">第 5 章 CPU 调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.3.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu-io-%E5%8C%BA%E9%97%B4"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">CPU-I&#x2F;O 区间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu-%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">CPU 调度程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A6"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">抢占调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B4%BE%E7%A8%8B%E5%BA%8F-dispatcher"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">分派程序 Dispatcher</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99-scheduling-criteria"><span class="toc-number">2.3.2.</span> <span class="toc-text">调度准则 Scheduling Criteria</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%88%B0%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">先到先服务调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">最短作业优先调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">优先级调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E8%BD%AC%E6%B3%95%E8%B0%83%E5%BA%A6"><span class="toc-number">2.3.3.4.</span> <span class="toc-text">轮转法调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6"><span class="toc-number">2.3.3.5.</span> <span class="toc-text">多级队列调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6"><span class="toc-number">2.3.3.6.</span> <span class="toc-text">多级反馈队列调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6"><span class="toc-number">2.3.4.</span> <span class="toc-text">多处理器调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">多处理器调度的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E4%BA%B2%E5%92%8C%E6%80%A7"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">处理器亲和性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">负载平衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.3.4.4.</span> <span class="toc-text">对称多线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">2.3.5.</span> <span class="toc-text">线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%9E%E4%BA%89%E8%8C%83%E5%9B%B4"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">竞争范围</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AF%84%E4%BC%B0"><span class="toc-number">2.3.6.</span> <span class="toc-text">算法评估</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">确定类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E9%98%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">排队模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-6-%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">2.4.</span> <span class="toc-text">第 6 章 进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.1.</span> <span class="toc-text">临界区问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E8%A7%A3%E6%B3%95"><span class="toc-number">2.4.2.</span> <span class="toc-text">一些解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#peterson-%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.3.</span> <span class="toc-text">Peterson 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%90%8C%E6%AD%A5"><span class="toc-number">2.4.4.</span> <span class="toc-text">硬件同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.4.5.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF"><span class="toc-number">2.4.5.1.</span> <span class="toc-text">死锁和饥饿</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.6.</span> <span class="toc-text">经典同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%BC%93%E5%86%B2%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">有限缓冲问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.6.2.</span> <span class="toc-text">读者 - 写者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.6.3.</span> <span class="toc-text">哲学家进餐问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B-monitors"><span class="toc-number">2.4.7.</span> <span class="toc-text">管程 Monitors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.7.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%A1%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.4.7.2.</span> <span class="toc-text">哲学家进餐问题的管程解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E7%AE%A1%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.7.3.</span> <span class="toc-text">基于信号量的管程实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E5%86%85%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%87%8D%E5%90%AF"><span class="toc-number">2.4.7.4.</span> <span class="toc-text">管程内的进程重启</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.4.8.</span> <span class="toc-text">同步实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-%E5%90%8C%E6%AD%A5"><span class="toc-number">2.4.8.1.</span> <span class="toc-text">Pthread 同步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.4.9.</span> <span class="toc-text">原子事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-7-%E7%AB%A0-%E6%AD%BB%E9%94%81"><span class="toc-number">2.5.</span> <span class="toc-text">第 7 章 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.5.1.</span> <span class="toc-text">系统模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%89%B9%E5%BE%81"><span class="toc-number">2.5.2.</span> <span class="toc-text">死锁特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">必要条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">资源分配图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.3.</span> <span class="toc-text">死锁处理方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-number">2.5.4.</span> <span class="toc-text">死锁预防</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%A0%E6%9C%89%E5%B9%B6%E7%AD%89%E5%BE%85"><span class="toc-number">2.5.4.2.</span> <span class="toc-text">占有并等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0"><span class="toc-number">2.5.4.3.</span> <span class="toc-text">非抢占</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85"><span class="toc-number">2.5.4.4.</span> <span class="toc-text">循环等待</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-number">2.5.5.</span> <span class="toc-text">死锁避免</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81"><span class="toc-number">2.5.5.1.</span> <span class="toc-text">安全状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.5.2.</span> <span class="toc-text">资源分配图算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.5.3.</span> <span class="toc-text">银行家算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.5.3.1.</span> <span class="toc-text">安全性算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.5.3.2.</span> <span class="toc-text">资源请求算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">2.5.6.</span> <span class="toc-text">死锁检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%8F%E7%A7%8D%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E5%8F%AA%E6%9C%89%E5%8D%95%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.5.6.1.</span> <span class="toc-text">每种资源类型只有单个实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%8F%E7%A7%8D%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E5%8F%AF%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.5.6.2.</span> <span class="toc-text">每种资源类型可有多个实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.6.3.</span> <span class="toc-text">应用检测算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D"><span class="toc-number">2.5.7.</span> <span class="toc-text">死锁恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2-2"><span class="toc-number">2.5.7.1.</span> <span class="toc-text">进程终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%8A%A2%E5%8D%A0"><span class="toc-number">2.5.7.2.</span> <span class="toc-text">资源抢占</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.8.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">第三部分 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-8-%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">第 8 章 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">3.1.1.</span> <span class="toc-text">背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A1%AC%E4%BB%B6"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">基本硬件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%BB%91%E5%AE%9A"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">地址绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">逻辑地址空间与物理地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">动态加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="toc-number">3.1.1.5.</span> <span class="toc-text">动态链接与共享库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2"><span class="toc-number">3.1.2.</span> <span class="toc-text">交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">3.1.3.</span> <span class="toc-text">连续内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E4%B8%8E%E4%BF%9D%E6%8A%A4"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">内存映射与保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A2%8E%E7%89%87"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">碎片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5"><span class="toc-number">3.1.4.</span> <span class="toc-text">分页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">基本方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">硬件支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%A1%B5"><span class="toc-number">3.1.4.4.</span> <span class="toc-text">共享页</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.5.</span> <span class="toc-text">页表结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">层次页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">哈希页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.1.5.3.</span> <span class="toc-text">反向页表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-number">3.1.6.</span> <span class="toc-text">分段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95-2"><span class="toc-number">3.1.6.1.</span> <span class="toc-text">基本方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6"><span class="toc-number">3.1.6.2.</span> <span class="toc-text">硬件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-9-%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">3.2.</span> <span class="toc-text">第 9 章 虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF-2"><span class="toc-number">3.2.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%9C%80%E8%B0%83%E9%A1%B5"><span class="toc-number">3.2.2.</span> <span class="toc-text">按需调页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E9%9C%80%E8%B0%83%E9%A1%B5%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">按需调页的性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="toc-number">3.2.3.</span> <span class="toc-text">写时复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.2.4.</span> <span class="toc-text">页面置换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%A1%B5%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">基本页置换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fifo-%E9%A1%B5%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">FIFO 页置换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.2.4.3.</span> <span class="toc-text">最优置换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lru-%E9%A1%B5%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.2.4.4.</span> <span class="toc-text">LRU 页置换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%91%E4%BC%BC-lru-%E9%A1%B5%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.2.4.5.</span> <span class="toc-text">近似 LRU 页置换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E5%BC%95%E7%94%A8%E4%BD%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.4.5.1.</span> <span class="toc-text">附加引用位算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.4.5.2.</span> <span class="toc-text">二次机会算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E5%9E%8B%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.4.5.3.</span> <span class="toc-text">增强型二次机会算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%AE%A1%E6%95%B0%E7%9A%84%E9%A1%B5%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.2.4.6.</span> <span class="toc-text">基于计数的页置换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%B8%8D%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E9%A1%B5%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.4.6.1.</span> <span class="toc-text">最不经常使用页置换算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B8%B8%E4%BD%BF%E7%94%A8%E9%A1%B5%E6%94%AF%E6%8F%B4%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.4.6.2.</span> <span class="toc-text">最常使用页支援算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%BC%93%E5%86%B2%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.4.7.</span> <span class="toc-text">页缓冲算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E9%A1%B5%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.2.4.8.</span> <span class="toc-text">应用程序与页置换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A7%E5%88%86%E9%85%8D"><span class="toc-number">3.2.5.</span> <span class="toc-text">帧分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A7%E7%9A%84%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">帧的最少数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">分配算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%88%86%E9%85%8D%E4%B8%8E%E5%B1%80%E9%83%A8%E5%88%86%E9%85%8D"><span class="toc-number">3.2.5.3.</span> <span class="toc-text">全局分配与局部分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%A2%A0%E7%B0%B8"><span class="toc-number">3.2.6.</span> <span class="toc-text">系统颠簸</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%A2%A0%E7%B0%B8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.2.6.1.</span> <span class="toc-text">系统颠簸的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E5%90%88%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.6.2.</span> <span class="toc-text">工作集合模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%94%99%E8%AF%AF%E9%A2%91%E7%8E%87"><span class="toc-number">3.2.6.3.</span> <span class="toc-text">页错误频率</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.7.</span> <span class="toc-text">内存映射文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D"><span class="toc-number">3.2.8.</span> <span class="toc-text">内核内存的分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%80%83%E8%99%91"><span class="toc-number">3.2.9.</span> <span class="toc-text">其他考虑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E8%B0%83%E9%A1%B5"><span class="toc-number">3.2.9.1.</span> <span class="toc-text">预调页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.2.9.2.</span> <span class="toc-text">页大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tlb-%E8%8C%83%E5%9B%B4"><span class="toc-number">3.2.9.3.</span> <span class="toc-text">TLB 范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E9%A1%B5%E8%A1%A8-2"><span class="toc-number">3.2.9.4.</span> <span class="toc-text">反向页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.9.5.</span> <span class="toc-text">程序结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-%E4%BA%92%E9%94%81"><span class="toc-number">3.2.9.6.</span> <span class="toc-text">I&#x2F;O 互锁</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">第四部分 存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-10-%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.</span> <span class="toc-text">第 10 章 文件系统接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.1.</span> <span class="toc-text">文件概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">文件属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">文件操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">文件类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.1.4.</span> <span class="toc-text">文件结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.1.5.</span> <span class="toc-text">内部文件结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.2.</span> <span class="toc-text">访问方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%AE%BF%E9%97%AE"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">顺序访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">直接访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">其他访问方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.3.</span> <span class="toc-text">目录结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-2"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">目录概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%B1%82%E7%BB%93%E6%9E%84%E7%9B%AE%E5%BD%95"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">单层结构目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E7%BB%93%E6%9E%84%E7%9B%AE%E5%BD%95"><span class="toc-number">4.1.3.4.</span> <span class="toc-text">双重结构目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E7%BB%93%E6%9E%84%E7%9B%AE%E5%BD%95"><span class="toc-number">4.1.3.5.</span> <span class="toc-text">树状结构目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95"><span class="toc-number">4.1.3.6.</span> <span class="toc-text">无环图目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%9B%BE%E7%9B%AE%E5%BD%95"><span class="toc-number">4.1.3.7.</span> <span class="toc-text">通用图目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD"><span class="toc-number">4.1.4.</span> <span class="toc-text">文件系统挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">4.1.5.</span> <span class="toc-text">文件共享</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%94%A8%E6%88%B7"><span class="toc-number">4.1.5.1.</span> <span class="toc-text">多用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.1.5.2.</span> <span class="toc-text">远程文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E8%AF%AD%E4%B9%89"><span class="toc-number">4.1.5.3.</span> <span class="toc-text">一致性语义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4-2"><span class="toc-number">4.1.6.</span> <span class="toc-text">保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.6.1.</span> <span class="toc-text">访问类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">4.1.6.2.</span> <span class="toc-text">访问控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BF%9D%E6%8A%A4%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.6.3.</span> <span class="toc-text">其他保护方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-11-%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">第 11 章 文件系统的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.1.</span> <span class="toc-text">文件系统结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.2.</span> <span class="toc-text">文件系统实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">分区与安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">虚拟文件系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">目录实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%88%97%E8%A1%A8"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">线性列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">哈希表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.4.</span> <span class="toc-text">分配方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">链接分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">索引分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">4.2.5.</span> <span class="toc-text">空闲空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E5%90%91%E9%87%8F"><span class="toc-number">4.2.5.1.</span> <span class="toc-text">位向量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">4.2.5.2.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84"><span class="toc-number">4.2.5.3.</span> <span class="toc-text">组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0"><span class="toc-number">4.2.5.4.</span> <span class="toc-text">计数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E4%B8%8E%E6%80%A7%E8%83%BD"><span class="toc-number">4.2.6.</span> <span class="toc-text">效率与性能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E7%8E%87"><span class="toc-number">4.2.6.1.</span> <span class="toc-text">效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">4.2.6.2.</span> <span class="toc-text">性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D"><span class="toc-number">4.2.7.</span> <span class="toc-text">恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">4.2.7.1.</span> <span class="toc-text">一致性检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="toc-number">4.2.7.2.</span> <span class="toc-text">备份和恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.2.8.</span> <span class="toc-text">基于日志结构的文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nfs"><span class="toc-number">4.2.9.</span> <span class="toc-text">NFS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.2.9.1.</span> <span class="toc-text">安装协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nfs-%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.2.9.2.</span> <span class="toc-text">NFS 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%90%8D%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.2.9.3.</span> <span class="toc-text">路径名转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.9.4.</span> <span class="toc-text">远程操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-12-%E7%AB%A0-%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.</span> <span class="toc-text">第 12 章 大容量存储器的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">大容量存储器结构简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">磁盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E5%B8%A6"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">磁带</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.2.</span> <span class="toc-text">磁盘结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E9%99%84%E5%B1%9E"><span class="toc-number">4.3.3.</span> <span class="toc-text">磁盘附属</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E9%99%84%E5%B1%9E%E5%AD%98%E5%82%A8"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">主机附属存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%99%84%E5%B1%9E%E5%AD%98%E5%82%A8"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">网络附属存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E7%BD%91%E7%BB%9C"><span class="toc-number">4.3.3.3.</span> <span class="toc-text">存储区域网络</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.4.</span> <span class="toc-text">磁盘调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fcfs-%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">FCFS 调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sstf-%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">SSTF 调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scan-%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.4.3.</span> <span class="toc-text">SCAN 调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-scan-%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.4.4.</span> <span class="toc-text">C-SCAN 调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#look-%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.4.5.</span> <span class="toc-text">LOOK 调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">4.3.4.6.</span> <span class="toc-text">磁盘调度算法的选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.5.</span> <span class="toc-text">磁盘管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">4.3.5.1.</span> <span class="toc-text">磁盘格式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E5%9D%97"><span class="toc-number">4.3.5.2.</span> <span class="toc-text">引导块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%8F%E5%9D%97"><span class="toc-number">4.3.5.3.</span> <span class="toc-text">坏块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.6.</span> <span class="toc-text">交换空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.6.1.</span> <span class="toc-text">交换空间的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">4.3.6.2.</span> <span class="toc-text">交换空间的位置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raid-%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.7.</span> <span class="toc-text">RAID 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%86%97%E4%BD%99%E6%94%B9%E5%96%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">4.3.7.1.</span> <span class="toc-text">通过冗余改善可靠性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD"><span class="toc-number">4.3.7.2.</span> <span class="toc-text">通过并行处理改善性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raid-%E7%BA%A7%E5%88%AB"><span class="toc-number">4.3.7.3.</span> <span class="toc-text">RAID 级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raid-%E7%BA%A7%E5%88%AB%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">4.3.7.4.</span> <span class="toc-text">RAID 级别的选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">4.3.7.5.</span> <span class="toc-text">扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raid-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.7.6.</span> <span class="toc-text">RAID 的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.8.</span> <span class="toc-text">稳定存储实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.9.</span> <span class="toc-text">三级存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87"><span class="toc-number">4.3.9.1.</span> <span class="toc-text">三级存储设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%94%AF%E6%8C%81"><span class="toc-number">4.3.9.2.</span> <span class="toc-text">操作系统支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD-2"><span class="toc-number">4.3.9.3.</span> <span class="toc-text">性能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-13-%E7%AB%A0-io-%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.4.</span> <span class="toc-text">第 13 章 I&#x2F;O 输入系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">4.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-%E7%A1%AC%E4%BB%B6"><span class="toc-number">4.4.2.</span> <span class="toc-text">I&#x2F;O 硬件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">轮询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD-2"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="toc-number">4.4.2.3.</span> <span class="toc-text">直接内存访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93"><span class="toc-number">4.4.2.4.</span> <span class="toc-text">通道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-%E5%BA%94%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.4.3.</span> <span class="toc-text">I&#x2F;O 应用接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%97%E4%B8%8E%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">块与字符设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">网络设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E-io"><span class="toc-number">4.4.3.3.</span> <span class="toc-text">阻塞和非阻塞 I&#x2F;O</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-%E5%86%85%E6%A0%B8%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.4.4.</span> <span class="toc-text">I&#x2F;O 内核子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io-%E8%B0%83%E5%BA%A6"><span class="toc-number">4.4.4.1.</span> <span class="toc-text">I&#x2F;O 调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2-2"><span class="toc-number">4.4.4.2.</span> <span class="toc-text">缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98-2"><span class="toc-number">4.4.4.3.</span> <span class="toc-text">高速缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%87%E8%84%B1%E6%9C%BA%E4%B8%8E%E8%AE%BE%E5%A4%87%E9%A2%84%E7%95%99"><span class="toc-number">4.4.4.4.</span> <span class="toc-text">假脱机与设备预留</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">4.4.4.5.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-%E4%BF%9D%E6%8A%A4"><span class="toc-number">4.4.4.6.</span> <span class="toc-text">I&#x2F;O 保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.4.7.</span> <span class="toc-text">内核数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8-io-%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93"><span class="toc-number">4.4.4.8.</span> <span class="toc-text">内核 I&#x2F;O 子系统总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A-io-%E6%93%8D%E4%BD%9C%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%A1%AC%E4%BB%B6"><span class="toc-number">4.4.5.</span> <span class="toc-text">把 I&#x2F;O 操作转化为硬件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81"><span class="toc-number">4.4.6.</span> <span class="toc-text">流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD-3"><span class="toc-number">4.4.7.</span> <span class="toc-text">性能</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/08/11/%E6%9C%9F%E6%9C%AB/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" rel="bookmark" title="期末复习资料">期末复习资料</a></li><li class="active"><a href="/2021/09/29/%E6%9C%9F%E6%9C%AB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%20%E7%AC%94%E8%AE%B0/" rel="bookmark" title="操作系统概念 笔记">操作系统概念 笔记</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="lzs" data-src="/images/avatar.jpg"><p class="name" itemprop="name">lzs</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">31</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">12</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">33</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3plbmdzaGVuZ2xpNzc1" title="https:&#x2F;&#x2F;github.com&#x2F;zengshengli775"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9senMtNDg=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;lzs-48"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE4ODAwNzc0NjY=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1880077466"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9naXRlZS5jb20vemVuZ3NoZW5nbGk3NzUvemVuZ3NoZW5nbGk3NzU=" title="https:&#x2F;&#x2F;gitee.com&#x2F;zengshengli775&#x2F;zengshengli775"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/09/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/10/01/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" title="分类于 实用技巧">实用技巧</a></div><span><a href="/2021/08/25/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/Mac%20VScode%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="Mac VScode快捷键">Mac VScode快捷键</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="分类于 机器学习">机器学习</a></div><span><a href="/2021/09/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%8F%201.Introduction/" title="机器学习算法公式 1.Introduction">机器学习算法公式 1.Introduction</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="分类于 编程基础">编程基础</a></div><span><a href="/2021/09/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="C语言基础知识">C语言基础知识</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%9C%9F%E6%9C%AB/" title="分类于 期末">期末</a></div><span><a href="/2021/08/11/%E6%9C%9F%E6%9C%AB/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" title="期末复习资料">期末复习资料</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" title="分类于 实用技巧">实用技巧</a></div><span><a href="/2021/08/13/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/Macbookpro%E6%81%A2%E5%A4%8D%E5%A4%B1%E7%81%B5%E7%9A%84Type-c%E6%8E%A5%E5%8F%A3/" title="Macbookpro恢复失灵的Type-c接口">Macbookpro恢复失灵的Type-c接口</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="分类于 机器学习">机器学习</a></div><span><a href="/2021/09/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%8F%202.%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" title="机器学习算法公式 2.线性回归">机器学习算法公式 2.线性回归</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="分类于 机器学习">机器学习</a></div><span><a href="/2021/08/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/" title="机器学习基础">机器学习基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%A7%91%E7%A0%94/" title="分类于 科研">科研</a></div><span><a href="/2021/08/25/%E7%A7%91%E7%A0%94/%E7%A7%91%E7%A0%94%E6%96%87%E7%8C%AE%E7%BD%91%E7%AB%99/" title="科研文献网站">科研文献网站</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%A8%B1%E4%B9%90/" title="分类于 娱乐">娱乐</a></div><span><a href="/2021/08/10/%E5%A8%B1%E4%B9%90/%E5%A8%B1%E4%B9%90%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB/" title="娱乐网站汇总">娱乐网站汇总</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%9A%E5%AE%A2/" title="分类于 博客">博客</a></div><span><a href="/2021/08/11/%E5%8D%9A%E5%AE%A2/%E8%BD%AC%E8%BD%BD%E5%8D%9A%E5%AE%A2%E6%96%B9%E6%B3%95/" title="转载博客方法">转载博客方法</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">lzs @ Sakura</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">224k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:24</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/09/29/期末/操作系统概念 笔记/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->